
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>r2libs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/arturoeanton/go-r2lang/pkg/r2libs/commons.go (16.7%)</option>
				
				<option value="file1">github.com/arturoeanton/go-r2lang/pkg/r2libs/commonsDetectContentType.go (0.0%)</option>
				
				<option value="file2">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2collections.go (0.0%)</option>
				
				<option value="file3">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2date.go (67.1%)</option>
				
				<option value="file4">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2db.go (71.7%)</option>
				
				<option value="file5">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2go.go (0.0%)</option>
				
				<option value="file6">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2goroutine.r2.go (0.0%)</option>
				
				<option value="file7">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2hack.go (0.0%)</option>
				
				<option value="file8">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2http.go (0.0%)</option>
				
				<option value="file9">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2httpclient.go (0.0%)</option>
				
				<option value="file10">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2io.go (2.0%)</option>
				
				<option value="file11">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2lang_graph.go (90.9%)</option>
				
				<option value="file12">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2lib.go (0.0%)</option>
				
				<option value="file13">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2math.go (9.5%)</option>
				
				<option value="file14">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2os.go (1.7%)</option>
				
				<option value="file15">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2print.go (1.0%)</option>
				
				<option value="file16">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2rand.go (4.0%)</option>
				
				<option value="file17">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2requests.go (77.9%)</option>
				
				<option value="file18">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2soap.go (77.5%)</option>
				
				<option value="file19">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2std.go (34.0%)</option>
				
				<option value="file20">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2string.go (5.8%)</option>
				
				<option value="file21">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2test.go (2.6%)</option>
				
				<option value="file22">github.com/arturoeanton/go-r2lang/pkg/r2libs/r2unicode.go (20.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package r2libs

import (
        "strconv"
        "github.com/arturoeanton/go-r2lang/pkg/r2core"
)

func toFloat(val interface{}) float64 <span class="cov8" title="1">{
        switch v := val.(type) </span>{
        case float64:<span class="cov8" title="1">
                return v</span>
        case int:<span class="cov0" title="0">
                return float64(v)</span>
        case bool:<span class="cov0" title="0">
                if v </span><span class="cov0" title="0">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>
        case nil:<span class="cov0" title="0">
                return 0</span>
        case string:<span class="cov0" title="0">
                f, err := strconv.ParseFloat(v, 64)
                if err != nil </span><span class="cov0" title="0">{
                        panic("Cannot convert string to number:" + v)</span>
                }
                <span class="cov0" title="0">return f</span>
        }
        <span class="cov0" title="0">panic("Cannot convert value to number")</span>
}
func toBool(val interface{}) bool <span class="cov0" title="0">{
        if val == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">switch v := val.(type) </span>{
        case bool:<span class="cov0" title="0">
                return v</span>
        case float64:<span class="cov0" title="0">
                return v != 0</span>
        case int:<span class="cov0" title="0">
                return v != 0</span>
        case string:<span class="cov0" title="0">
                return v != ""</span>
        }
        <span class="cov0" title="0">return true</span>
}

// Para unificar la lógica numérica en "=="
func isNumeric(v interface{}) bool <span class="cov0" title="0">{
        switch v.(type) </span>{
        case float64, int:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Corrige la comparación "=="
func equals(a, b interface{}) bool <span class="cov0" title="0">{
        // Si ambos son numéricos, compare con toFloat
        if isNumeric(a) &amp;&amp; isNumeric(b) </span><span class="cov0" title="0">{
                return toFloat(a) == toFloat(b)
        }</span>
        // sino comparamos string/bool/nil
        <span class="cov0" title="0">switch aa := a.(type) </span>{
        case string:<span class="cov0" title="0">
                if bb, ok := b.(string); ok </span><span class="cov0" title="0">{
                        return aa == bb
                }</span>
        case bool:<span class="cov0" title="0">
                if bb, ok := b.(bool); ok </span><span class="cov0" title="0">{
                        return aa == bb
                }</span>
        case nil:<span class="cov0" title="0">
                return b == nil</span>
        }
        <span class="cov0" title="0">return false</span>
}

// RegisterModule registers a module with its functions under a namespace
func RegisterModule(env *r2core.Environment, moduleName string, functions map[string]r2core.BuiltinFunction) <span class="cov8" title="1">{
        module := make(map[string]interface{})
        for name, fn := range functions </span><span class="cov8" title="1">{
                module[name] = fn
        }</span>
        <span class="cov8" title="1">env.Set(moduleName, module)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package r2libs

import (
        "encoding/json"
        "encoding/xml"
        "regexp"
        "strings"
)

// ContentType representa el tipo de contenido detectado.
type ContentType int

const (
        Unknown ContentType = iota
        JSONType
        XMLType
        HTMLType
        TextType
)

// String convierte el ContentType a una representación en string.
func (c ContentType) String() string <span class="cov0" title="0">{
        switch c </span>{
        case JSONType:<span class="cov0" title="0">
                return "application/json"</span>
        case XMLType:<span class="cov0" title="0">
                return "application/xml"</span>
        case HTMLType:<span class="cov0" title="0">
                return "text/html"</span>
        case TextType:<span class="cov0" title="0">
                return "text/plain"</span>
        default:<span class="cov0" title="0">
                return "text/plain"</span>
        }
}

// DetectContentType determina si una cadena es JSON, XML, HTML o Texto Plano.
func DetectContentType(input string) ContentType <span class="cov0" title="0">{
        trimmed := strings.TrimSpace(input)
        if len(trimmed) == 0 </span><span class="cov0" title="0">{
                return Unknown
        }</span>

        <span class="cov0" title="0">firstChar := trimmed[0]

        // Heurísticas Iniciales
        switch firstChar </span>{
        case '{', '[':<span class="cov0" title="0">
                // Posible JSON
                if isJSON(trimmed) </span><span class="cov0" title="0">{
                        return JSONType
                }</span>
        case '&lt;':<span class="cov0" title="0">
                // Posible XML o HTML
                if strings.HasPrefix(trimmed, "&lt;!DOCTYPE html") || strings.HasPrefix(strings.ToLower(trimmed), "&lt;html") </span><span class="cov0" title="0">{
                        if isHTML(trimmed) </span><span class="cov0" title="0">{
                                return HTMLType
                        }</span>
                }
                <span class="cov0" title="0">if isHTML(trimmed) </span><span class="cov0" title="0">{
                        return HTMLType
                }</span>
                <span class="cov0" title="0">if isXML(trimmed) </span><span class="cov0" title="0">{
                        return XMLType
                }</span>

        }

        // Intentar parsear como JSON
        <span class="cov0" title="0">if isJSON(trimmed) </span><span class="cov0" title="0">{
                return JSONType
        }</span>

        // Intentar parsear como XML
        <span class="cov0" title="0">if isXML(trimmed) </span><span class="cov0" title="0">{
                return XMLType
        }</span>

        // Intentar parsear como HTML
        <span class="cov0" title="0">if isHTML(trimmed) </span><span class="cov0" title="0">{
                return HTMLType
        }</span>

        // Si ninguna coincide, clasificar como Texto Plano
        <span class="cov0" title="0">return TextType</span>
}

// isJSON intenta deserializar la cadena como JSON.
func isJSON(input string) bool <span class="cov0" title="0">{
        var js interface{}
        return json.Unmarshal([]byte(input), &amp;js) == nil
}</span>

// isXML intenta deserializar la cadena como XML.
func isXML(input string) bool <span class="cov0" title="0">{
        var x interface{}
        return xml.Unmarshal([]byte(input), &amp;x) == nil
}</span>

// isHTML intenta determinar si una cadena es HTML utilizando expresiones regulares.
func isHTML(input string) bool <span class="cov0" title="0">{
        // Expresiones regulares básicas para detectar HTML
        htmlPatterns := []string{
                `(?i)&lt;!DOCTYPE\s+html&gt;`, // &lt;!DOCTYPE html&gt;
                `(?i)&lt;html\b`,           // &lt;html
                `(?i)&lt;head\b`,           // &lt;head
                `(?i)&lt;body\b`,           // &lt;body
                `(?i)&lt;div\b`,            // &lt;div
                `(?i)&lt;span\b`,           // &lt;span
                `(?i)&lt;p\b`,              // &lt;p
                `(?i)&lt;a\b`,              // &lt;a
                `(?i)&lt;script\b`,         // &lt;script
                `(?i)&lt;style\b`,          // &lt;style
        }

        for _, pattern := range htmlPatterns </span><span class="cov0" title="0">{
                matched, err := regexp.MatchString(pattern, input)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Ignorar errores en la expresión regular
                }
                <span class="cov0" title="0">if matched </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package r2libs

import "github.com/arturoeanton/go-r2lang/pkg/r2core"

// r2hack.go: Funciones de "seguridad", "forense" y "análisis" para R2.
// Enfoque didáctico, no pretende ser una suite de hacking real.

func RegisterCollections(env *r2core.Environment) <span class="cov0" title="0">{
        functions := map[string]r2core.BuiltinFunction{
                "range": r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                        if len(args) != 2 </span><span class="cov0" title="0">{
                                panic("range: solo se aceptan 2 argumentos")</span>
                        }
                        <span class="cov0" title="0">start := int(args[0].(float64))
                        end := int(args[1].(float64))
                        if start &gt; end </span><span class="cov0" title="0">{
                                panic("range: start no puede ser mayor que end")</span>
                        }
                        <span class="cov0" title="0">arr := make([]interface{}, end-start)
                        for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                                arr[i-start] = i
                        }</span>
                        <span class="cov0" title="0">return arr</span>
                }),

                "repeat": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) != 2 </span><span class="cov0" title="0">{
                                panic("repeat: solo se aceptan 2 argumentos")</span>
                        }
                        <span class="cov0" title="0">start := 0
                        end := int(args[0].(float64))
                        if start &gt; end </span><span class="cov0" title="0">{
                                panic("range: start no puede ser mayor que end")</span>
                        }
                        <span class="cov0" title="0">arr := make([]interface{}, end-start)
                        for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                                arr[i-start] = args[1]
                        }</span>
                        <span class="cov0" title="0">return arr</span>
                }),

                "copy": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                panic("copy: solo se acepta un argumento")</span>
                        }

                        <span class="cov0" title="0">arr := args[0].([]interface{})
                        newArr := make([]interface{}, len(arr))
                        copy(newArr, arr)

                        return newArr</span>
                }),

                "slice": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) != 3 </span><span class="cov0" title="0">{
                                panic("slice: solo se aceptan 3 argumentos")</span>
                        }

                        <span class="cov0" title="0">arr := args[0].([]interface{})
                        start := args[1].(int)
                        end := args[2].(int)

                        if start &lt; 0 || start &gt;= len(arr) </span><span class="cov0" title="0">{
                                panic("slice: start fuera de rango")</span>
                        }

                        <span class="cov0" title="0">if end &lt; 0 || end &gt;= len(arr) </span><span class="cov0" title="0">{
                                panic("slice: end fuera de rango")</span>
                        }

                        <span class="cov0" title="0">return arr[start:end]</span>
                }),
        }
        
        <span class="cov0" title="0">RegisterModule(env, "collections", functions)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package r2libs

import (
        "time"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"
)

func RegisterDate(env *r2core.Environment) <span class="cov8" title="1">{
        functions := map[string]r2core.BuiltinFunction{
                "Date": r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                        return createDateObject()
                }</span>),
        }
        
        <span class="cov8" title="1">RegisterModule(env, "date", functions)</span>
}

func createDateObject() map[string]interface{} <span class="cov8" title="1">{
        obj := make(map[string]interface{})
        obj["now"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                return &amp;r2core.DateValue{Time: time.Now()}
        }</span>)
        <span class="cov8" title="1">obj["today"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                return &amp;r2core.DateValue{Time: time.Now().Truncate(24 * time.Hour)}
        }</span>)
        <span class="cov8" title="1">obj["create"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                if len(args) &lt; 3 </span><span class="cov0" title="0">{
                        return nil // Error: requires at least 3 arguments
                }</span>
                <span class="cov8" title="1">year := int(args[0].(float64))
                month := time.Month(int(args[1].(float64)))
                day := int(args[2].(float64))
                hour, minute, second := 0, 0, 0
                if len(args) &gt; 3 </span><span class="cov8" title="1">{
                        hour = int(args[3].(float64))
                }</span>
                <span class="cov8" title="1">if len(args) &gt; 4 </span><span class="cov8" title="1">{
                        minute = int(args[4].(float64))
                }</span>
                <span class="cov8" title="1">if len(args) &gt; 5 </span><span class="cov8" title="1">{
                        second = int(args[5].(float64))
                }</span>
                <span class="cov8" title="1">return &amp;r2core.DateValue{Time: time.Date(year, month, day, hour, minute, second, 0, time.Local)}</span>
        })
        <span class="cov8" title="1">obj["getYear"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                date, ok := args[0].(*r2core.DateValue)
                if !ok </span><span class="cov0" title="0">{
                        return nil // Error: requires a Date object
                }</span>
                <span class="cov0" title="0">return float64(date.Time.Year())</span>
        })
        <span class="cov8" title="1">obj["getMonth"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                date, ok := args[0].(*r2core.DateValue)
                if !ok </span><span class="cov0" title="0">{
                        return nil // Error: requires a Date object
                }</span>
                <span class="cov0" title="0">return float64(date.Time.Month())</span>
        })
        <span class="cov8" title="1">obj["getDay"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                date, ok := args[0].(*r2core.DateValue)
                if !ok </span><span class="cov0" title="0">{
                        return nil // Error: requires a Date object
                }</span>
                <span class="cov0" title="0">return float64(date.Time.Day())</span>
        })
        <span class="cov8" title="1">obj["format"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        return nil // Error: requires a Date object and a format string
                }</span>
                <span class="cov8" title="1">date, ok := args[0].(*r2core.DateValue)
                if !ok </span><span class="cov0" title="0">{
                        return nil // Error: requires a Date object
                }</span>
                <span class="cov8" title="1">format, ok := args[1].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil // Error: requires a string as format
                }</span>
                <span class="cov8" title="1">goFormat := r2core.ConvertToGoFormat(format)
                return date.Time.Format(goFormat)</span>
        })
        <span class="cov8" title="1">obj["timezone"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                if len(args) &lt; 4 </span><span class="cov0" title="0">{
                        return nil // Error: requires at least 4 arguments
                }</span>
                <span class="cov8" title="1">timezone, ok := args[0].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil // Error: requires a string as timezone
                }</span>
                <span class="cov8" title="1">loc, err := time.LoadLocation(timezone)
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Error: invalid timezone
                }</span>
                <span class="cov8" title="1">year := int(args[1].(float64))
                month := time.Month(int(args[2].(float64)))
                day := int(args[3].(float64))
                hour, minute, second := 0, 0, 0
                if len(args) &gt; 4 </span><span class="cov0" title="0">{
                        hour = int(args[4].(float64))
                }</span>
                <span class="cov8" title="1">if len(args) &gt; 5 </span><span class="cov0" title="0">{
                        minute = int(args[5].(float64))
                }</span>
                <span class="cov8" title="1">if len(args) &gt; 6 </span><span class="cov0" title="0">{
                        second = int(args[6].(float64))
                }</span>
                <span class="cov8" title="1">return &amp;r2core.DateValue{Time: time.Date(year, month, day, hour, minute, second, 0, loc)}</span>
        })
        <span class="cov8" title="1">obj["toTimezone"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        return nil // Error: requires a Date object and a timezone string
                }</span>
                <span class="cov8" title="1">date, ok := args[0].(*r2core.DateValue)
                if !ok </span><span class="cov0" title="0">{
                        return nil // Error: requires a Date object
                }</span>
                <span class="cov8" title="1">timezone, ok := args[1].(string)
                if !ok </span><span class="cov0" title="0">{
                        return nil // Error: requires a string as timezone
                }</span>
                <span class="cov8" title="1">loc, err := time.LoadLocation(timezone)
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Error: invalid timezone
                }</span>
                <span class="cov8" title="1">return &amp;r2core.DateValue{Time: date.Time.In(loc)}</span>
        })
        <span class="cov8" title="1">return obj</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package r2libs

import (
        "database/sql"
        "fmt"
        "strconv"
        "strings"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"

        // Database drivers - imported anonymously
        _ "github.com/go-sql-driver/mysql"
        _ "github.com/lib/pq"
        _ "github.com/mattn/go-sqlite3"
)

// r2db.go: Database connectivity functions for R2Lang

// Global map to store database connections
var dbConnections = make(map[string]*sql.DB)

func RegisterDB(env *r2core.Environment) <span class="cov8" title="1">{
        functions := map[string]r2core.BuiltinFunction{
                "dbConnect": r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        panic("dbConnect needs (driver, dataSourceName)")</span>
                }
                <span class="cov8" title="1">driver := toString(args[0])
                dsn := toString(args[1])

                // Validate driver
                supportedDrivers := []string{"sqlite3", "postgres", "mysql"}
                isSupported := false
                for _, d := range supportedDrivers </span><span class="cov8" title="1">{
                        if d == driver </span><span class="cov8" title="1">{
                                isSupported = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !isSupported </span><span class="cov8" title="1">{
                        panic(fmt.Sprintf("dbConnect: unsupported driver '%s'. Supported: %v", driver, supportedDrivers))</span>
                }

                <span class="cov8" title="1">db, err := sql.Open(driver, dsn)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("dbConnect: failed to open database: %v", err))</span>
                }

                <span class="cov8" title="1">err = db.Ping()
                if err != nil </span><span class="cov0" title="0">{
                        db.Close()
                        panic(fmt.Sprintf("dbConnect: failed to ping database: %v", err))</span>
                }

                // Generate connection ID
                <span class="cov8" title="1">connId := fmt.Sprintf("conn_%d", len(dbConnections))
                dbConnections[connId] = db

                return connId</span>
        }),

        "dbQuery": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov8" title="1">{
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        panic("dbQuery needs (connectionId, query, ...args)")</span>
                }
                <span class="cov8" title="1">connId := toString(args[0])
                query := toString(args[1])

                db, exists := dbConnections[connId]
                if !exists </span><span class="cov8" title="1">{
                        panic(fmt.Sprintf("dbQuery: connection '%s' not found", connId))</span>
                }

                // Prepare arguments for query
                <span class="cov8" title="1">queryArgs := make([]interface{}, len(args)-2)
                for i, arg := range args[2:] </span><span class="cov8" title="1">{
                        queryArgs[i] = arg
                }</span>

                <span class="cov8" title="1">rows, err := db.Query(query, queryArgs...)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("dbQuery: %v", err))</span>
                }
                <span class="cov8" title="1">defer rows.Close()

                // Get column names
                columns, err := rows.Columns()
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("dbQuery: failed to get columns: %v", err))</span>
                }

                // Prepare result slice
                <span class="cov8" title="1">var results []interface{}

                for rows.Next() </span><span class="cov8" title="1">{
                        // Create slice for scanning
                        values := make([]interface{}, len(columns))
                        valuePtrs := make([]interface{}, len(columns))
                        for i := range values </span><span class="cov8" title="1">{
                                valuePtrs[i] = &amp;values[i]
                        }</span>

                        <span class="cov8" title="1">err := rows.Scan(valuePtrs...)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("dbQuery: failed to scan row: %v", err))</span>
                        }

                        // Create map for this row
                        <span class="cov8" title="1">rowMap := make(map[string]interface{})
                        for i, col := range columns </span><span class="cov8" title="1">{
                                // Convert []uint8 to string if needed
                                if b, ok := values[i].([]uint8); ok </span><span class="cov0" title="0">{
                                        rowMap[col] = string(b)
                                }</span> else<span class="cov8" title="1"> {
                                        rowMap[col] = values[i]
                                }</span>
                        }

                        <span class="cov8" title="1">results = append(results, rowMap)</span>
                }

                <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("dbQuery: row iteration error: %v", err))</span>
                }

                <span class="cov8" title="1">return results</span>
        }),

        "dbExec": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov8" title="1">{
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        panic("dbExec needs (connectionId, query, ...args)")</span>
                }
                <span class="cov8" title="1">connId := toString(args[0])
                query := toString(args[1])

                db, exists := dbConnections[connId]
                if !exists </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("dbExec: connection '%s' not found", connId))</span>
                }

                // Prepare arguments for query
                <span class="cov8" title="1">queryArgs := make([]interface{}, len(args)-2)
                for i, arg := range args[2:] </span><span class="cov8" title="1">{
                        queryArgs[i] = arg
                }</span>

                <span class="cov8" title="1">result, err := db.Exec(query, queryArgs...)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("dbExec: %v", err))</span>
                }

                <span class="cov8" title="1">rowsAffected, err := result.RowsAffected()
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("dbExec: failed to get rows affected: %v", err))</span>
                }

                <span class="cov8" title="1">return rowsAffected</span>
        }),

        "dbClose": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov8" title="1">{
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        panic("dbClose needs (connectionId)")</span>
                }
                <span class="cov8" title="1">connId := toString(args[0])

                db, exists := dbConnections[connId]
                if !exists </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("dbClose: connection '%s' not found", connId))</span>
                }

                <span class="cov8" title="1">err := db.Close()
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("dbClose: %v", err))</span>
                }

                <span class="cov8" title="1">delete(dbConnections, connId)
                return true</span>
        }),

        "dbBegin": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        panic("dbBegin needs (connectionId)")</span>
                }
                <span class="cov0" title="0">connId := toString(args[0])

                db, exists := dbConnections[connId]
                if !exists </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("dbBegin: connection '%s' not found", connId))</span>
                }

                <span class="cov0" title="0">_, err := db.Begin()
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("dbBegin: %v", err))</span>
                }

                // For now, return a simple transaction ID
                // In a real implementation, you would store the *sql.Tx separately
                <span class="cov0" title="0">txId := fmt.Sprintf("tx_%s_%d", connId, len(dbConnections))
                return txId</span>
        }),

        "dbLastInsertId": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov8" title="1">{
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        panic("dbLastInsertId needs (connectionId, query, ...args)")</span>
                }
                <span class="cov8" title="1">connId := toString(args[0])
                query := toString(args[1])

                db, exists := dbConnections[connId]
                if !exists </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("dbLastInsertId: connection '%s' not found", connId))</span>
                }

                // Prepare arguments for query
                <span class="cov8" title="1">queryArgs := make([]interface{}, len(args)-2)
                for i, arg := range args[2:] </span><span class="cov8" title="1">{
                        queryArgs[i] = arg
                }</span>

                <span class="cov8" title="1">result, err := db.Exec(query, queryArgs...)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("dbLastInsertId: %v", err))</span>
                }

                <span class="cov8" title="1">lastId, err := result.LastInsertId()
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("dbLastInsertId: failed to get last insert id: %v", err))</span>
                }

                <span class="cov8" title="1">return lastId</span>
        }),

        "dbPing": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov8" title="1">{
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        panic("dbPing needs (connectionId)")</span>
                }
                <span class="cov8" title="1">connId := toString(args[0])

                db, exists := dbConnections[connId]
                if !exists </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("dbPing: connection '%s' not found", connId))</span>
                }

                <span class="cov8" title="1">err := db.Ping()
                return err == nil</span>
        }),

        "dbEscape": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov8" title="1">{
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        panic("dbEscape needs (value)")</span>
                }
                <span class="cov8" title="1">value := toString(args[0])
                // Simple SQL escape - replace single quotes with double single quotes
                return strings.ReplaceAll(value, "'", "''")</span>
        }),

        "dbGetConnections": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov8" title="1">{
                var connIds []interface{}
                for connId := range dbConnections </span><span class="cov8" title="1">{
                        if !strings.HasPrefix(connId, "tx_") </span><span class="cov8" title="1">{ // Exclude transaction IDs
                                connIds = append(connIds, connId)
                        }</span>
                }
                <span class="cov8" title="1">return connIds</span>
        }),
        }
        
        <span class="cov8" title="1">RegisterModule(env, "db", functions)</span>
}

// Helper function to convert interface{} to string
func toString(v interface{}) string <span class="cov8" title="1">{
        switch val := v.(type) </span>{
        case string:<span class="cov8" title="1">
                return val</span>
        case float64:<span class="cov0" title="0">
                return strconv.FormatFloat(val, 'f', -1, 64)</span>
        case int:<span class="cov0" title="0">
                return strconv.Itoa(val)</span>
        case bool:<span class="cov0" title="0">
                return strconv.FormatBool(val)</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("%v", val)</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package r2libs

import (
        "fmt"
        "reflect"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"
)

// Estructura que podemos usar para simular objetos Go
// Se crea con "goNew('MyStruct')" y se guarda en un *GoObject
type GoObject struct {
        value reflect.Value
}

// Eval =&gt; no hace nada especial
func (g *GoObject) Eval(env *r2core.Environment) interface{} <span class="cov0" title="0">{
        return g
}</span>

// r2go.go: Interoperabilidad con Go

// Un pequeño registro de funciones Go que deseamos exponer a R2
// map[funcName -&gt; reflect.Value]
var goFuncRegistry = make(map[string]reflect.Value)

// Un pequeño registro de “constructores” (structName -&gt; función constructor)
var goStructRegistry = make(map[string]func() interface{})

// RegisterGoInterOp: expone funciones que permiten a R2 usar el registro
func RegisterGoInterOp(env *r2core.Environment) <span class="cov0" title="0">{

        // 1) goRegisterFunc("nombre", GoFuncion)
        //    =&gt; En Go:   goRegisterFunc("miSum", reflect.ValueOf(MiSum))
        //    =&gt; En R2:   callGoFunc("miSum", 10, 20)
        env.Set("goRegisterFunc", r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        panic("goRegisterFunc necesita (name, goFuncValueReflect)")</span>
                }
                <span class="cov0" title="0">_, ok1 := args[0].(string)
                if !ok1 </span><span class="cov0" title="0">{
                        panic("goRegisterFunc: primer arg debe ser string")</span>
                }
                // El segundo arg DEBE ser un reflect.Value dentro de Go,
                // pero como no se puede pasar reflect.Value desde R2, simulemos
                // que lo guardamos en 'goFuncRegistry' manualmente en Go.
                // =&gt; “Truco”: generamos un panic pidiendo que se registre desde Go.
                // Este ejemplo asume que la parte en Go hará:
                //    goFuncRegistry["miSum"] = reflect.ValueOf(MiSum)
                // y en R2 se llama "callGoFunc".
                <span class="cov0" title="0">panic("goRegisterFunc: se debe llamar desde Go, no desde R2, para inyectar la reflect.Value. (Truco de ejemplo)")</span>
        }))

        // 2) callGoFunc("nombre", arg1, arg2, ...)
        //    =&gt; Llama a la función de Go que se registró en goFuncRegistry
        <span class="cov0" title="0">env.Set("callGoFunc", r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        panic("callGoFunc necesita (funcName, ...)")</span>
                }
                <span class="cov0" title="0">funcName, ok := args[0].(string)
                if !ok </span><span class="cov0" title="0">{
                        panic("callGoFunc: primer arg debe ser string (funcName)")</span>
                }
                <span class="cov0" title="0">fnVal, found := goFuncRegistry[funcName]
                if !found </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("callGoFunc: no se encontró la función '%s' en goFuncRegistry", funcName))</span>
                }
                <span class="cov0" title="0">if fnVal.Kind() != reflect.Func </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("callGoFunc: '%s' no es una función", funcName))</span>
                }
                // Convertimos los args[1..] a reflect.Value
                <span class="cov0" title="0">callArgs := make([]reflect.Value, len(args)-1)
                for i := 1; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                        callArgs[i-1] = reflect.ValueOf(args[i])
                }</span>
                // Llamamos la función
                <span class="cov0" title="0">results := fnVal.Call(callArgs)
                // Si hay 0 resultados =&gt; nil
                if len(results) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                // si 1 =&gt; lo retornamos
                <span class="cov0" title="0">if len(results) == 1 </span><span class="cov0" title="0">{
                        return results[0].Interface()
                }</span>
                // si mas =&gt; array
                <span class="cov0" title="0">arr := make([]interface{}, len(results))
                for i, r := range results </span><span class="cov0" title="0">{
                        arr[i] = r.Interface()
                }</span>
                <span class="cov0" title="0">return arr</span>
        }))

        // 3) goRegisterStruct("Nombre", constructor)
        // =&gt; para permitir goNew("Nombre") en R2
        <span class="cov0" title="0">env.Set("goRegisterStruct", r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                panic("goRegisterStruct: se debe llamar desde Go con la map, no desde R2 (Truco).")</span>
        }))

        // 4) goNew(structName) =&gt; crea un objeto Go y retorna un *GoObject
        <span class="cov0" title="0">env.Set("goNew", r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        panic("goNew necesita (structName)")</span>
                }
                <span class="cov0" title="0">sName, ok := args[0].(string)
                if !ok </span><span class="cov0" title="0">{
                        panic("goNew: arg debe ser string (structName)")</span>
                }
                <span class="cov0" title="0">constructor, found := goStructRegistry[sName]
                if !found </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("goNew: no existe struct '%s' en goStructRegistry", sName))</span>
                }
                <span class="cov0" title="0">inst := constructor() // crea una instancia
                return &amp;GoObject{value: reflect.ValueOf(inst)}</span>
        }))

        // 5) goSetField(goObj, "FieldName", value)
        // =&gt; setea un campo exportado en la struct
        <span class="cov0" title="0">env.Set("goSetField", r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                if len(args) &lt; 3 </span><span class="cov0" title="0">{
                        panic("goSetField(goObj, fieldName, value)")</span>
                }
                <span class="cov0" title="0">obj, ok1 := args[0].(*GoObject)
                fieldName, ok2 := args[1].(string)
                if !(ok1 &amp;&amp; ok2) </span><span class="cov0" title="0">{
                        panic("goSetField: (GoObject, string, value)")</span>
                }
                <span class="cov0" title="0">val := args[2]

                // reflexion para setear
                v := obj.value
                if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        v = v.Elem()
                }</span>
                <span class="cov0" title="0">fieldVal := v.FieldByName(fieldName)
                if !fieldVal.IsValid() </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("goSetField: no existe el field '%s'", fieldName))</span>
                }
                <span class="cov0" title="0">if !fieldVal.CanSet() </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("goSetField: field '%s' no se puede setear (exportado?)", fieldName))</span>
                }
                <span class="cov0" title="0">fieldVal.Set(reflect.ValueOf(val))
                return nil</span>
        }))

        // 6) goGetField(goObj, "FieldName") =&gt; obtiene un campo
        <span class="cov0" title="0">env.Set("goGetField", r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        panic("goGetField(goObj, fieldName)")</span>
                }
                <span class="cov0" title="0">obj, ok1 := args[0].(*GoObject)
                fieldName, ok2 := args[1].(string)
                if !(ok1 &amp;&amp; ok2) </span><span class="cov0" title="0">{
                        panic("goGetField: (GoObject, string)")</span>
                }
                <span class="cov0" title="0">v := obj.value
                if v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        v = v.Elem()
                }</span>
                <span class="cov0" title="0">fieldVal := v.FieldByName(fieldName)
                if !fieldVal.IsValid() </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("goGetField: no existe field '%s'", fieldName))</span>
                }
                <span class="cov0" title="0">return fieldVal.Interface()</span>
        }))

        // 7) goCallMethod(goObj, "MethodName", ...args)
        // =&gt; llama un método exportado en la struct
        <span class="cov0" title="0">env.Set("goCallMethod", r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        panic("goCallMethod(goObj, methodName, ...)")</span>
                }
                <span class="cov0" title="0">obj, ok1 := args[0].(*GoObject)
                methodName, ok2 := args[1].(string)
                if !(ok1 &amp;&amp; ok2) </span><span class="cov0" title="0">{
                        panic("goCallMethod: (GoObject, string, ...)")</span>
                }
                <span class="cov0" title="0">callArgs := args[2:] // lo que sigue son parámetros
                // reflexion
                v := obj.value
                m := v.MethodByName(methodName)
                if !m.IsValid() </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("goCallMethod: no existe método '%s'", methodName))</span>
                }
                // convert callArgs =&gt; reflect.Value
                <span class="cov0" title="0">inVals := make([]reflect.Value, len(callArgs))
                for i := 0; i &lt; len(callArgs); i++ </span><span class="cov0" title="0">{
                        inVals[i] = reflect.ValueOf(callArgs[i])
                }</span>
                <span class="cov0" title="0">results := m.Call(inVals)
                if len(results) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if len(results) == 1 </span><span class="cov0" title="0">{
                        return results[0].Interface()
                }</span>
                <span class="cov0" title="0">arr := make([]interface{}, len(results))
                for i, r := range results </span><span class="cov0" title="0">{
                        arr[i] = r.Interface()
                }</span>
                <span class="cov0" title="0">return arr</span>
        }))
}

// En Go, para registrar tus funciones y structs:

// goFuncRegistry["miSuma"] = reflect.ValueOf(func(a,b int) int {return a+b})
// goStructRegistry["Persona"] = func() interface{} { return &amp;Persona{} }
</pre>
		
		<pre class="file" id="file6" style="display: none">package r2libs

import (
        "sync"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"
)

// Semaphore estructura
type Semaphore struct {
        ch chan struct{}
}

// NewSemaphore crea un nuevo semáforo con el número dado de permisos
func NewSemaphore(permits int) *Semaphore <span class="cov0" title="0">{
        return &amp;Semaphore{
                ch: make(chan struct{}, permits),
        }
}</span>

// Acquire obtiene un permiso del semáforo
func (s *Semaphore) Acquire() <span class="cov0" title="0">{
        s.ch &lt;- struct{}{}
}</span>

// Release libera un permiso del semáforo
func (s *Semaphore) Release() <span class="cov0" title="0">{
        &lt;-s.ch
}</span>

// Builtin function para crear un semáforo
func builtinSemaphore(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                panic("semaphore necesita exactamente un argumento: número de permisos")</span>
        }
        <span class="cov0" title="0">permitCount, ok := args[0].(float64)
        if !ok </span><span class="cov0" title="0">{
                panic("semaphore: el argumento debe ser un número")</span>
        }
        <span class="cov0" title="0">if permitCount &lt; 1 </span><span class="cov0" title="0">{
                panic("semaphore: el número de permisos debe ser al menos 1")</span>
        }
        <span class="cov0" title="0">sem := NewSemaphore(int(permitCount))
        return sem</span>
}

// Builtin functions para adquirir y liberar semáforos
func builtinAcquireSemaphore(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                panic("acquire necesita exactamente un argumento: semáforo")</span>
        }
        <span class="cov0" title="0">sem, ok := args[0].(*Semaphore)
        if !ok </span><span class="cov0" title="0">{
                panic("acquire: el argumento debe ser un semáforo")</span>
        }
        <span class="cov0" title="0">sem.Acquire()
        return nil</span>
}

func builtinReleaseSemaphore(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                panic("release necesita exactamente un argumento: semáforo")</span>
        }
        <span class="cov0" title="0">sem, ok := args[0].(*Semaphore)
        if !ok </span><span class="cov0" title="0">{
                panic("release: el argumento debe ser un semáforo")</span>
        }
        <span class="cov0" title="0">sem.Release()
        return nil</span>
}

// r2goroutine.go (continuación)

// Monitor estructura
type Monitor struct {
        mutex sync.Mutex
        cond  *sync.Cond
}

// NewMonitor crea un nuevo monitor
func NewMonitor() *Monitor <span class="cov0" title="0">{
        m := &amp;Monitor{}
        m.cond = sync.NewCond(&amp;m.mutex)
        return m
}</span>

// Lock adquiere el mutex del monitor
func (m *Monitor) Lock() <span class="cov0" title="0">{
        m.mutex.Lock()
}</span>

// Unlock libera el mutex del monitor
func (m *Monitor) Unlock() <span class="cov0" title="0">{
        m.mutex.Unlock()
}</span>

// Wait espera en la condición del monitor
func (m *Monitor) Wait() <span class="cov0" title="0">{
        m.cond.Wait()
}</span>

// Signal despierta una goroutine esperando en la condición
func (m *Monitor) Signal() <span class="cov0" title="0">{
        m.cond.Signal()
}</span>

// Broadcast despierta todas las goroutines esperando en la condición
func (m *Monitor) Broadcast() <span class="cov0" title="0">{
        m.cond.Broadcast()
}</span>

// Builtin function para crear un monitor
func builtinMonitor(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) != 0 </span><span class="cov0" title="0">{
                panic("monitor no necesita argumentos")</span>
        }
        <span class="cov0" title="0">mon := NewMonitor()
        return mon</span>
}

// Builtin functions para operar sobre monitores
func builtinLock(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                panic("lock necesita exactamente un argumento: monitor")</span>
        }
        <span class="cov0" title="0">mon, ok := args[0].(*Monitor)
        if !ok </span><span class="cov0" title="0">{
                panic("lock: el argumento debe ser un monitor")</span>
        }
        <span class="cov0" title="0">mon.Lock()
        return nil</span>
}

func builtinUnlock(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                panic("unlock necesita exactamente un argumento: monitor")</span>
        }
        <span class="cov0" title="0">mon, ok := args[0].(*Monitor)
        if !ok </span><span class="cov0" title="0">{
                panic("unlock: el argumento debe ser un monitor")</span>
        }
        <span class="cov0" title="0">mon.Unlock()
        return nil</span>
}

func builtinWait(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                panic("wait necesita exactamente un argumento: monitor")</span>
        }
        <span class="cov0" title="0">mon, ok := args[0].(*Monitor)
        if !ok </span><span class="cov0" title="0">{
                panic("wait: el argumento debe ser un monitor")</span>
        }
        <span class="cov0" title="0">mon.Wait()
        return nil</span>
}

func builtinSignal(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                panic("signal necesita exactamente un argumento: monitor")</span>
        }
        <span class="cov0" title="0">mon, ok := args[0].(*Monitor)
        if !ok </span><span class="cov0" title="0">{
                panic("signal: el argumento debe ser un monitor")</span>
        }
        <span class="cov0" title="0">mon.Signal()
        return nil</span>
}

func builtinBroadcast(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                panic("broadcast necesita exactamente un argumento: monitor")</span>
        }
        <span class="cov0" title="0">mon, ok := args[0].(*Monitor)
        if !ok </span><span class="cov0" title="0">{
                panic("broadcast: el argumento debe ser un monitor")</span>
        }
        <span class="cov0" title="0">mon.Broadcast()
        return nil</span>
}

func builtinWaitAll(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                panic("waitAll necesita exactamente un argumento: monitor o semáforo")</span>
        }
        <span class="cov0" title="0">mon, ok := args[0].(*Monitor)
        if !ok </span><span class="cov0" title="0">{
                sem, ok := args[0].(*Semaphore)
                if !ok </span><span class="cov0" title="0">{
                        panic("waitAll: el argumento debe ser un monitor o semáforo")</span>
                }
                <span class="cov0" title="0">sem.Acquire()
                return nil</span>
        }
        <span class="cov0" title="0">mon.Broadcast()
        return nil</span>
}

// r2goroutine.go (continuación)

func RegisterConcurrency(env *r2core.Environment) <span class="cov0" title="0">{
        functions := map[string]r2core.BuiltinFunction{
                "semaphore": r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                        return builtinSemaphore(args...)
                }</span>),
                "acquire": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        return builtinAcquireSemaphore(args...)
                }</span>),
                "release": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        return builtinReleaseSemaphore(args...)
                }</span>),
                "monitor": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        return builtinMonitor(args...)
                }</span>),
                "lock": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        return builtinLock(args...)
                }</span>),
                "unlock": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        return builtinUnlock(args...)
                }</span>),
                "wait": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        return builtinWait(args...)
                }</span>),
                "signal": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        return builtinSignal(args...)
                }</span>),
                "broadcast": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        return builtinBroadcast(args...)
                }</span>),
                "waitAll": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        return builtinWaitAll(args...)
                }</span>),
        }
        
        <span class="cov0" title="0">RegisterModule(env, "goroutine", functions)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package r2libs

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/hmac"
        "crypto/md5"
        "crypto/rand"
        "crypto/rsa"
        "crypto/sha1"
        "crypto/sha256"
        "encoding/base64"
        "encoding/hex"
        "fmt"
        "io"
        "math/big"
        "net"
        "strconv"
        "strings"
        "time"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"
)

// r2hack.go: Funciones de "seguridad", "forense" y "análisis" para R2.
// Enfoque didáctico, no pretende ser una suite de hacking real.

func RegisterHack(env *r2core.Environment) <span class="cov0" title="0">{
        functions := map[string]r2core.BuiltinFunction{
                "hashMD5":       hashMD5,
                "hashSHA1":      hashSHA1,
                "hashSHA256":    hashSHA256,
                "base64Encode":  base64Encode,
                "base64Decode":  base64Decode,
                "portScan":      portScan,
                "whois":         whois,
                "hexdump":       hexdump,
                "hmacSHA256":    hmacSHA256,
                "aesEncrypt":    aesEncrypt,
                "aesDecrypt":    aesDecrypt,
                "dnsLookup":     dnsLookup,
                "dnsLookupAddr": dnsLookupAddr,
                "simplePing":    simplePing,
                "quickRSA":      quickRSA,
                "rsaEncrypt":    rsaEncrypt,
                "rsaDecrypt":    rsaDecrypt,
        }

        RegisterModule(env, "hack", functions)
}</span>

var hashMD5 = r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                panic("hashMD5 needs (str)")</span>
        }
        <span class="cov0" title="0">s, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("hashMD5: arg must be string")</span>
        }
        <span class="cov0" title="0">sum := md5.Sum([]byte(s))
        return fmt.Sprintf("%x", sum)</span>
})

var hashSHA1 = r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                panic("hashSHA1 needs (str)")</span>
        }
        <span class="cov0" title="0">s, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("hashSHA1: arg must be string")</span>
        }
        <span class="cov0" title="0">sum := sha1.Sum([]byte(s))
        return fmt.Sprintf("%x", sum)</span>
})

var hashSHA256 = r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                panic("hashSHA256 needs (str)")</span>
        }
        <span class="cov0" title="0">s, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("hashSHA256: arg must be string")</span>
        }
        <span class="cov0" title="0">sum := sha256.Sum256([]byte(s))
        return fmt.Sprintf("%x", sum)</span>
})

var base64Encode = r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                panic("base64Encode needs (str)")</span>
        }
        <span class="cov0" title="0">s, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("base64Encode: arg must be string")</span>
        }
        <span class="cov0" title="0">return base64.StdEncoding.EncodeToString([]byte(s))</span>
})

var base64Decode = r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                panic("base64Decode needs (str)")</span>
        }
        <span class="cov0" title="0">s, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("base64Decode: arg must be string")</span>
        }
        <span class="cov0" title="0">decoded, err := base64.StdEncoding.DecodeString(s)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("base64Decode: error =&gt; %v", err)
        }</span>
        <span class="cov0" title="0">return string(decoded)</span>
})

var portScan = r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 3 </span><span class="cov0" title="0">{
                panic("portScan needs (host, startPort, endPort)")</span>
        }
        <span class="cov0" title="0">host, ok1 := args[0].(string)
        startP := int(toFloat(args[1]))
        endP := int(toFloat(args[2]))
        if !ok1 </span><span class="cov0" title="0">{
                panic("portScan: host debe ser string")</span>
        }
        <span class="cov0" title="0">if startP &lt; 1 || endP &gt; 65535 || endP &lt; startP </span><span class="cov0" title="0">{
                panic("portScan: invalid port range")</span>
        }
        <span class="cov0" title="0">var openPorts []interface{}
        for port := startP; port &lt;= endP; port++ </span><span class="cov0" title="0">{
                portStr := strconv.Itoa(port)
                address := net.JoinHostPort(host, portStr)
                conn, err := net.DialTimeout("tcp", address, 300*time.Millisecond)
                if err == nil </span><span class="cov0" title="0">{
                        // Conexión exitosa =&gt; puerto abierto
                        conn.Close()
                        openPorts = append(openPorts, float64(port))
                }</span>
        }
        <span class="cov0" title="0">return openPorts</span>
})

var whois = r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                panic("whois needs (domain)")</span>
        }
        <span class="cov0" title="0">domain, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("whois: arg must be string")</span>
        }
        // Podrías llamar un "execCmd" si tienes uno, o un net.Dial("tcp", "whois.server.com:43")
        // Simplificado =&gt; net.Dial con whois.verisign-grs.com:43
        <span class="cov0" title="0">conn, err := net.Dial("tcp", "whois.verisign-grs.com:43")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Error connecting to whois: %v", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()
        // Enviar dominio +
        conn.Write([]byte(domain + ""))
        // Leer respuesta
        var sb strings.Builder
        buf := make([]byte, 1024)
        for </span><span class="cov0" title="0">{
                n, err := conn.Read(buf)
                if n &gt; 0 </span><span class="cov0" title="0">{
                        sb.Write(buf[:n])
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return sb.String()</span>
})

var hexdump = r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                panic("hexdump needs (str)")</span>
        }
        <span class="cov0" title="0">s, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("hexdump: arg must be a string (or base64 binary)")</span>
        }
        <span class="cov0" title="0">data := []byte(s)
        // Generar volcado
        var sb strings.Builder
        for i := 0; i &lt; len(data); i += 16 </span><span class="cov0" title="0">{
                line := data[i:]
                if len(line) &gt; 16 </span><span class="cov0" title="0">{
                        line = line[:16]
                }</span>
                // offset
                <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("%08x  ", i))
                // hex
                for j := 0; j &lt; 16; j++ </span><span class="cov0" title="0">{
                        if j &lt; len(line) </span><span class="cov0" title="0">{
                                sb.WriteString(fmt.Sprintf("%02x ", line[j]))
                        }</span> else<span class="cov0" title="0"> {
                                sb.WriteString("   ")
                        }</span>
                        <span class="cov0" title="0">if j == 7 </span><span class="cov0" title="0">{
                                sb.WriteString(" ")
                        }</span>
                }
                <span class="cov0" title="0">sb.WriteString(" |")
                // ASCII
                for _, b := range line </span><span class="cov0" title="0">{
                        if b &gt;= 32 &amp;&amp; b &lt; 127 </span><span class="cov0" title="0">{
                                sb.WriteByte(b)
                        }</span> else<span class="cov0" title="0"> {
                                sb.WriteByte('.')
                        }</span>
                }
                <span class="cov0" title="0">sb.WriteString("|")</span>
        }
        <span class="cov0" title="0">return sb.String()</span>
})

var hmacSHA256 = r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                panic("hmacSHA256 needs (key, message)")</span>
        }
        <span class="cov0" title="0">k, ok1 := args[0].(string)
        m, ok2 := args[1].(string)
        if !(ok1 &amp;&amp; ok2) </span><span class="cov0" title="0">{
                panic("hmacSHA256: args must be strings")</span>
        }
        <span class="cov0" title="0">mac := hmac.New(sha256.New, []byte(k))
        mac.Write([]byte(m))
        return fmt.Sprintf("%x", mac.Sum(nil))</span>
})

var aesEncrypt = r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                panic("aesEncrypt needs (key, plaintext)")</span>
        }
        <span class="cov0" title="0">key, ok1 := args[0].(string)
        pt, ok2 := args[1].(string)
        if !(ok1 &amp;&amp; ok2) </span><span class="cov0" title="0">{
                panic("aesEncrypt: args must be strings")</span>
        }
        // crear block AES
        <span class="cov0" title="0">block, err := aes.NewCipher([]byte(key))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("aesEncrypt: error =&gt; %v", err)
        }</span>
        // generar IV
        <span class="cov0" title="0">iv := make([]byte, aes.BlockSize)
        if _, err := io.ReadFull(rand.Reader, iv); err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("aesEncrypt: error generating IV =&gt; %v", err)
        }</span>
        // modo CFB (simplificado), hay muchos modos
        <span class="cov0" title="0">stream := cipher.NewCFBEncrypter(block, iv)
        ciphertext := make([]byte, len(pt))
        stream.XORKeyStream(ciphertext, []byte(pt))
        // concatenamos IV + ciphertext en hex
        combined := append(iv, ciphertext...)
        return hex.EncodeToString(combined)</span>
})

var aesDecrypt = r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                panic("aesDecrypt needs (key, hexCipher)")</span>
        }
        <span class="cov0" title="0">key, ok1 := args[0].(string)
        hexCiph, ok2 := args[1].(string)
        if !(ok1 &amp;&amp; ok2) </span><span class="cov0" title="0">{
                panic("aesDecrypt: args must be strings")</span>
        }
        <span class="cov0" title="0">data, err := hex.DecodeString(hexCiph)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("aesDecrypt: error decode hex =&gt; %v", err)
        }</span>
        <span class="cov0" title="0">if len(data) &lt; aes.BlockSize </span><span class="cov0" title="0">{
                return "aesDecrypt: data too short"
        }</span>
        <span class="cov0" title="0">iv := data[:aes.BlockSize]
        ciph := data[aes.BlockSize:]
        block, err := aes.NewCipher([]byte(key))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("aesDecrypt: error =&gt; %v", err)
        }</span>
        <span class="cov0" title="0">stream := cipher.NewCFBDecrypter(block, iv)
        plaintext := make([]byte, len(ciph))
        stream.XORKeyStream(plaintext, ciph)
        return string(plaintext)</span>
})

var dnsLookup = r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                panic("dnsLookup needs (host)")</span>
        }
        <span class="cov0" title="0">host, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("dnsLookup: arg must be string")</span>
        }
        <span class="cov0" title="0">ips, err := net.LookupIP(host)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("dnsLookup: error =&gt; %v", err)
        }</span>
        <span class="cov0" title="0">var arr []interface{}
        for _, ip := range ips </span><span class="cov0" title="0">{
                arr = append(arr, ip.String())
        }</span>
        <span class="cov0" title="0">return arr</span>
})

var dnsLookupAddr = r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                panic("dnsLookupAddr needs (ip)")</span>
        }
        <span class="cov0" title="0">ip, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("dnsLookupAddr: arg must be string")</span>
        }
        <span class="cov0" title="0">names, err := net.LookupAddr(ip)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("dnsLookupAddr: error =&gt; %v", err)
        }</span>
        <span class="cov0" title="0">var arr []interface{}
        for _, nm := range names </span><span class="cov0" title="0">{
                arr = append(arr, nm)
        }</span>
        <span class="cov0" title="0">return arr</span>
})

var simplePing = r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                panic("simplePing needs (host)")</span>
        }
        <span class="cov0" title="0">host, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("simplePing: arg must be string")</span>
        }
        <span class="cov0" title="0">address := fmt.Sprintf("%s:80", host)
        conn, err := net.DialTimeout("tcp", address, 1*time.Second)
        if err == nil </span><span class="cov0" title="0">{
                conn.Close()
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
})

var quickRSA = r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
        var bitSize int = 2048
        if len(args) &gt;= 1 </span><span class="cov0" title="0">{
                bitSize = int(toFloat(args[0]))
        }</span>
        <span class="cov0" title="0">priv, err := rsa.GenerateKey(rand.Reader, bitSize)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("quickRSA: error =&gt; %v", err)
        }</span>
        <span class="cov0" title="0">pub := &amp;priv.PublicKey

        // Armamos un string toy:
        // ej. "RSA-PUB (N=12345, E=65537)"
        pubStr := fmt.Sprintf("RSA-PUB (N=%v, E=%v)", pub.N.String(), pub.E)

        // Incluimos N, E y D en la privada:
        privStr := fmt.Sprintf("RSA-PRIV (N=%v, E=%v, D=%v)",
                pub.N.String(), pub.E, priv.D.String())

        return []interface{}{pubStr, privStr}</span>
})

var rsaEncrypt = r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                panic("rsaEncrypt needs (pubStr, plaintext)")</span>
        }
        <span class="cov0" title="0">pubString, ok1 := args[0].(string)
        msg, ok2 := args[1].(string)
        if !(ok1 &amp;&amp; ok2) </span><span class="cov0" title="0">{
                panic("rsaEncrypt =&gt; (string, string)")</span>
        }
        // parse "RSA-PUB (N=..., E=...)"
        // muy naive parse
        <span class="cov0" title="0">nVal, eVal := parseRsaPubString(pubString)
        if nVal == nil </span><span class="cov0" title="0">{
                return "rsaEncrypt: error parse pubKey"
        }</span>
        <span class="cov0" title="0">pubKey := rsa.PublicKey{N: nVal, E: eVal}
        ciph, err := rsa.EncryptOAEP(sha256.New(), rand.Reader, &amp;pubKey, []byte(msg), nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("rsaEncrypt error =&gt; %v", err)
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(ciph)</span>
})

var rsaDecrypt = r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
        // rsaDecrypt(privString, hexCipher) =&gt; plaintext
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                panic("rsaDecrypt(privString, hexCiph)")</span>
        }
        <span class="cov0" title="0">privString, ok1 := args[0].(string)
        hexCiph, ok2 := args[1].(string)
        if !(ok1 &amp;&amp; ok2) </span><span class="cov0" title="0">{
                panic("rsaDecrypt =&gt; (string, string)")</span>
        }

        <span class="cov0" title="0">ciphData, err := hex.DecodeString(hexCiph)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("rsaDecrypt: decode error =&gt; %v", err)
        }</span>

        // parse =&gt; "RSA-PRIV (N=..., E=..., D=...)"
        <span class="cov0" title="0">nVal, eVal, dVal := parseRsaPrivString(privString)
        if nVal == nil || dVal == nil </span><span class="cov0" title="0">{
                return "rsaDecrypt: error parse privKey"
        }</span>

        // Construir PrivateKey "incompleto"
        <span class="cov0" title="0">priv := &amp;rsa.PrivateKey{
                PublicKey: rsa.PublicKey{
                        N: nVal,
                        E: eVal,
                },
                D: dVal,
                // Primes: nil =&gt; no tendremos la optimización de descifrado,
                // pero con set de Go 1.20+, es posible que Decrypt se queje
                // si no tenemos primes.
                // Haremos un fallback "toy" si no se queja:
        }
        // Precompute =&gt; a veces requiere primes
        // priv.Precompute() // Suele fallar si no tienes p y q

        // Decrypt:
        plaintext, err := rsa.DecryptOAEP(sha256.New(), rand.Reader, priv, ciphData, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("rsaDecrypt error =&gt; %v", err)
        }</span>
        <span class="cov0" title="0">return string(plaintext)</span>
})

func parseRsaPrivString(privStr string) (nVal *big.Int, eVal int, dVal *big.Int) <span class="cov0" title="0">{
        // Esperamos "RSA-PRIV (N=..., E=..., D=...)"
        start := strings.Index(privStr, "(")
        end := strings.LastIndex(privStr, ")")
        if start &lt; 0 || end &lt; 0 || end &lt;= start </span><span class="cov0" title="0">{
                return nil, 0, nil
        }</span>
        <span class="cov0" title="0">inside := privStr[start+1 : end] // "N=..., E=..., D=..."
        // Spliteamos por coma
        parts := strings.Split(inside, ",")
        // Esperamos 3 partes: N=..., E=..., D=...
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return nil, 0, nil
        }</span>
        <span class="cov0" title="0">var nStr, eStr, dStr string
        for _, p := range parts </span><span class="cov0" title="0">{
                p = strings.TrimSpace(p) // "N=xxx"
                if strings.HasPrefix(p, "N=") </span><span class="cov0" title="0">{
                        nStr = strings.TrimPrefix(p, "N=")
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(p, "E=") </span><span class="cov0" title="0">{
                        eStr = strings.TrimPrefix(p, "E=")
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(p, "D=") </span><span class="cov0" title="0">{
                        dStr = strings.TrimPrefix(p, "D=")
                }</span>
        }
        // parse nStr =&gt; big.Int
        <span class="cov0" title="0">nVal_ := new(big.Int)
        _, ok := nVal_.SetString(strings.TrimSpace(nStr), 10)
        if !ok </span><span class="cov0" title="0">{
                return nil, 0, nil
        }</span>
        // parse eStr =&gt; int
        <span class="cov0" title="0">eVal_ := 0
        fmt.Sscanf(strings.TrimSpace(eStr), "%d", &amp;eVal_)
        // parse dStr =&gt; big.Int
        dVal_ := new(big.Int)
        _, ok2 := dVal_.SetString(strings.TrimSpace(dStr), 10)
        if !ok2 </span><span class="cov0" title="0">{
                return nil, 0, nil
        }</span>
        <span class="cov0" title="0">return nVal_, eVal_, dVal_</span>
}

func parseRsaPubString(pubStr string) (*big.Int, int) <span class="cov0" title="0">{
        // Verificamos que empiece con "RSA-PUB"
        if !strings.HasPrefix(pubStr, "RSA-PUB") </span><span class="cov0" title="0">{
                return nil, 0
        }</span>
        // Buscamos el paréntesis de apertura "(" y el de cierre ")"
        <span class="cov0" title="0">start := strings.Index(pubStr, "(")
        end := strings.LastIndex(pubStr, ")")
        if start &lt; 0 || end &lt; 0 || end &lt;= start </span><span class="cov0" title="0">{
                return nil, 0
        }</span>
        // Extraemos la parte interior: "N=..., E=..."
        <span class="cov0" title="0">inside := pubStr[start+1 : end]
        // Dividimos por comas
        parts := strings.Split(inside, ",")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, 0
        }</span>
        <span class="cov0" title="0">var nStr, eStr string
        for _, p := range parts </span><span class="cov0" title="0">{
                p = strings.TrimSpace(p) // "N=xxx"
                if strings.HasPrefix(p, "N=") </span><span class="cov0" title="0">{
                        nStr = strings.TrimPrefix(p, "N=")
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(p, "E=") </span><span class="cov0" title="0">{
                        eStr = strings.TrimPrefix(p, "E=")
                }</span>
        }
        // Convertir nStr a *big.Int
        <span class="cov0" title="0">nVal := new(big.Int)
        _, ok := nVal.SetString(strings.TrimSpace(nStr), 10)
        if !ok </span><span class="cov0" title="0">{
                return nil, 0
        }</span>
        // Convertir eStr a int
        <span class="cov0" title="0">eVal := 0
        fmt.Sscanf(strings.TrimSpace(eStr), "%d", &amp;eVal)
        return nVal, eVal</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package r2libs

import (
        "bytes"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "io"
        "net/http"
        "strings"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"
)

// Definiremos una estructura para guardar las rutas
type r2Route struct {
        method  string
        pattern string
        //handlerName string
        handlerfx *r2core.UserFunction
        // Podrías también almacenar un compilado de regexp, si quisieras
}

// Guardamos las rutas en un slice (o array global) para simplificar
var r2Routes []r2Route

func httpHandler(args []interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 3 </span><span class="cov0" title="0">{
                panic("handler necesita 3 argumentos: (method, pattern, fx)")</span>
        }
        <span class="cov0" title="0">method, ok1 := args[0].(string)
        pattern, ok2 := args[1].(string)
        handler, ok3 := args[2].(*r2core.UserFunction)
        if !ok1 || !ok2 </span><span class="cov0" title="0">{
                panic("handler: should be (method, pattern, fx)")</span>
        }

        <span class="cov0" title="0">if !ok3 </span><span class="cov0" title="0">{
                panic("handler: fx should be a function")</span>
        }

        // Agregamos la ruta a la tabla
        <span class="cov0" title="0">r2Routes = append(r2Routes, r2Route{
                method:    strings.ToUpper(method),
                pattern:   pattern,
                handlerfx: handler,
        })
        return nil</span>
}

func RegisterHTTP(env *r2core.Environment) <span class="cov0" title="0">{
        functions := map[string]r2core.BuiltinFunction{
                "handler": r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                        return httpHandler(args)
                }</span>),

                "serve": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("serve needs 1 argument: (addr)")</span>
                        }
                        <span class="cov0" title="0">addr, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("serve: argument should be a string")</span>
                        }

                        // Definimos un único handler en Go para todas las rutas
                        <span class="cov0" title="0">http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                                // Leemos body (simple, para requests tipo POST/PUT)
                                var bodyStr string
                                if r.Method == "POST" || r.Method == "PUT" </span><span class="cov0" title="0">{
                                        data, err := io.ReadAll(r.Body)
                                        if err == nil </span><span class="cov0" title="0">{
                                                bodyStr = string(data)
                                        }</span>
                                }
                                // Buscamos una ruta que coincida con r.Method y r.URL.Path
                                <span class="cov0" title="0">route, pathVars := matchRoute(r2Routes, r.Method, r.URL.Path)
                                if route == nil </span><span class="cov0" title="0">{
                                        // No match
                                        w.WriteHeader(http.StatusNotFound)
                                        fmt.Fprintf(w, "404 Not Found\n")
                                        return
                                }</span>

                                <span class="cov0" title="0">r2Handler := route.handlerfx

                                // Llamamos la función con [pathVars, method, bodyStr]
                                // pathVars lo podemos pasar como map[string]interface{}
                                // En R2, el usuario lo recibe como un "obj", o un diccionario nativo:
                                pathVarsMap := make(map[string]interface{})
                                for k, v := range pathVars </span><span class="cov0" title="0">{
                                        pathVarsMap[k] = v
                                }</span>
                                <span class="cov0" title="0">argsR2 := []interface{}{pathVarsMap, r.Method, bodyStr}
                                respVal := r2Handler.Call(argsR2...)

                                // Si la respuesta es string, la imprimimos, si no, la convertimos
                                respStr, okResp := respVal.(string)
                                if !okResp </span><span class="cov0" title="0">{
                                        respCustom, okResp := respVal.(*r2core.ObjectInstance)
                                        var data map[string]interface{}
                                        if okResp </span><span class="cov0" title="0">{
                                                data = respCustom.Env.GetStore()
                                        }</span> else<span class="cov0" title="0"> {
                                                data, ok = respVal.(map[string]interface{})
                                                if !ok </span><span class="cov0" title="0">{
                                                        return
                                                }</span>
                                        }
                                        <span class="cov0" title="0">header, ok := data["header"].(map[string]interface{})
                                        if ok </span><span class="cov0" title="0">{
                                                for k, v := range header </span><span class="cov0" title="0">{
                                                        w.Header().Set(k, v.(string))
                                                }</span>
                                        }
                                        <span class="cov0" title="0">status, ok := data["status"]
                                        if ok </span><span class="cov0" title="0">{
                                                w.WriteHeader(status.(int))
                                        }</span>
                                        <span class="cov0" title="0">body, ok := data["body"]
                                        if ok </span><span class="cov0" title="0">{
                                                fmt.Fprint(w, body.(string))
                                                return
                                        }</span>
                                        <span class="cov0" title="0">fmt.Fprintf(w, "%v", respVal)
                                        return</span>
                                }
                                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
                                fmt.Fprint(w, respStr)</span>
                        })

                        // Arrancamos el servidor (bloqueante)
                        <span class="cov0" title="0">fmt.Println("Listening on ", addr)
                        err := http.ListenAndServe(addr, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("serve: error in ListenAndServe: %v", err))</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }),

                "vars": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("vars necesita 2 argumentos: (map, key)")</span>
                        }
                        // Verificamos tipos
                        <span class="cov0" title="0">theMap, ok1 := args[0].(map[string]interface{})
                        theKey, ok2 := args[1].(string)
                        if !ok1 || !ok2 </span><span class="cov0" title="0">{
                                panic("vars: primer argumento debe ser un map, segundo un string")</span>
                        }
                        // Intentamos extraer
                        <span class="cov0" title="0">value, found := theMap[theKey]
                        if !found </span><span class="cov0" title="0">{
                                // Retornamos nil si no está la clave
                                return nil
                        }</span>
                        <span class="cov0" title="0">return value</span>
                }),

                "XML": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) != 2 </span><span class="cov0" title="0">{
                                panic("XML needs at least 2 arguments")</span>
                        }
                        <span class="cov0" title="0">root, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("XML: argument must be a string")</span>
                        }
                        <span class="cov0" title="0">objectInstance, ok := args[1].(*r2core.ObjectInstance)
                        var instance map[string]interface{}
                        if !ok </span><span class="cov0" title="0">{
                                instance, ok = args[1].(map[string]interface{})
                                if !ok </span><span class="cov0" title="0">{
                                        panic("XML: argument must be an object or a map")</span>
                                }
                        } else<span class="cov0" title="0"> {
                                instance = objectInstance.Env.GetStore()
                        }</span>

                        <span class="cov0" title="0">instanceClean := removeBehavior(instance)
                        // Convertimos a JSON
                        data, err := mapToXML(root, instanceClean)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("XML: error in Marshal: %v", err))</span>
                        }
                        <span class="cov0" title="0">return string(data)</span>
                }),

                "HttpResponse": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("HttpResponse needs at least 1 argument")</span>
                        }
                        <span class="cov0" title="0">status, ok := args[0].(float64)
                        posArgs := 1
                        if !ok </span><span class="cov0" title="0">{
                                status = 200
                                posArgs = 0
                        }</span>
                        <span class="cov0" title="0">statusInt := int(status)
                        header := make(map[string]interface{})
                        body := ""

                        if len(args) &gt; posArgs </span><span class="cov0" title="0">{
                                header, ok = args[posArgs].(map[string]interface{})
                                if !ok </span><span class="cov0" title="0">{
                                        value, ok := args[posArgs].(string)
                                        if ok </span><span class="cov0" title="0">{
                                                if len(args) == (posArgs + 1) </span><span class="cov0" title="0">{
                                                        body = value
                                                        header = make(map[string]interface{})
                                                        header["Content-Type"] = DetectContentType(body).String()
                                                }</span> else<span class="cov0" title="0"> {
                                                        header = make(map[string]interface{})
                                                        header["Content-Type"] = value
                                                }</span>
                                        }

                                }
                        }
                        <span class="cov0" title="0">if len(args) == (posArgs + 2) </span><span class="cov0" title="0">{
                                body, ok = args[posArgs+1].(string)
                                if !ok </span><span class="cov0" title="0">{
                                        panic("HttpResponse: should be (status, header, body)")</span>
                                }
                        }
                        <span class="cov0" title="0">return map[string]interface{}{
                                "status": statusInt,
                                "header": header,
                                "body":   body,
                        }</span>
                }),

                "JSON": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("JSON needs at least 1 argument")</span>
                        }
                        <span class="cov0" title="0">var instance map[string]interface{}
                        objectInstance, ok := args[0].(*r2core.ObjectInstance)
                        if !ok </span><span class="cov0" title="0">{
                                instance, ok = args[0].(map[string]interface{})
                                if !ok </span><span class="cov0" title="0">{
                                        panic("JSON: argument must be an object or a map")</span>
                                }
                        } else<span class="cov0" title="0"> {
                                instance = objectInstance.Env.GetStore()
                        }</span>
                        <span class="cov0" title="0">instanceClean := removeBehavior(instance)
                        // Convertimos a JSON
                        data, err := json.Marshal(instanceClean)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("JSON: error in Marshal: %v", err))</span>
                        }
                        <span class="cov0" title="0">return string(data)</span>
                }),
        }
        
        <span class="cov0" title="0">RegisterModule(env, "http", functions)</span>
}

// mapToXML convierte un mapa a XML con un elemento raíz dinámico.
func mapToXML(root string, data map[string]interface{}) ([]byte, error) <span class="cov0" title="0">{
        // Crear un buffer para almacenar el XML
        var xmlData []byte
        // hacer el io writer
        xmlWriter := bytes.NewBuffer(xmlData)
        // Crear un encoder XML que escriba en el buffer
        encoder := xml.NewEncoder(xmlWriter)
        encoder.Indent("", "    ") // Formatear con indentación

        // Escribir el elemento raíz
        startElement := xml.StartElement{Name: xml.Name{Local: root}}
        if err := encoder.EncodeToken(startElement); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Función recursiva para procesar el mapa
        <span class="cov0" title="0">err := encodeMap(encoder, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Cerrar el elemento raíz
        <span class="cov0" title="0">if err := encoder.EncodeToken(startElement.End()); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Finalizar el encoder
        <span class="cov0" title="0">if err := encoder.Flush(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">xmlData = xmlWriter.Bytes()
        return xmlData, nil</span>
}

// encodeMap procesa un mapa y escribe sus elementos como sub-elementos XML.
func encodeMap(encoder *xml.Encoder, data map[string]interface{}) error <span class="cov0" title="0">{
        for key, value := range data </span><span class="cov0" title="0">{
                // Crear el elemento XML para la clave actual
                startElement := xml.StartElement{Name: xml.Name{Local: key}}

                switch v := value.(type) </span>{
                case map[string]interface{}:<span class="cov0" title="0">
                        // Si el valor es otro mapa, anidar elementos
                        if err := encoder.EncodeToken(startElement); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := encodeMap(encoder, v); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := encoder.EncodeToken(startElement.End()); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case []interface{}:<span class="cov0" title="0">
                        // Si el valor es una lista, iterar sobre ella
                        for _, item := range v </span><span class="cov0" title="0">{
                                if err := encoder.EncodeToken(startElement); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                // Asumimos que los elementos de la lista son básicos o mapas
                                <span class="cov0" title="0">switch itemVal := item.(type) </span>{
                                case map[string]interface{}:<span class="cov0" title="0">
                                        if err := encodeMap(encoder, itemVal); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                default:<span class="cov0" title="0">
                                        // Convertir el valor a string
                                        if err := encoder.EncodeToken(xml.CharData([]byte(fmt.Sprintf("%v", itemVal)))); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                                <span class="cov0" title="0">if err := encoder.EncodeToken(startElement.End()); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                default:<span class="cov0" title="0">
                        // Para tipos básicos, escribir el contenido
                        if err := encoder.EncodeElement(v, startElement); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func removeBehavior(instance map[string]interface{}) map[string]interface{} <span class="cov0" title="0">{
        instanceOut := make(map[string]interface{})
        for k, v := range instance </span><span class="cov0" title="0">{
                if k == "self" || k == "this" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if _, ok := v.(*r2core.UserFunction); ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if _, ok := v.(*r2core.BuiltinFunction); ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if subInstance, ok := v.(*r2core.ObjectInstance); ok </span><span class="cov0" title="0">{
                        instanceOut[k] = removeBehavior(subInstance.Env.GetStore())
                        continue</span>
                }
                <span class="cov0" title="0">instanceOut[k] = v</span>
        }
        <span class="cov0" title="0">return instanceOut</span>

}

// matchRoute busca en r2Routes la primera que coincida con method y path
// y retorna (rutaEncontrada, mapDeVariables). Si no hay match, retorna (nil, nil).
func matchRoute(routes []r2Route, method, path string) (*r2Route, map[string]string) <span class="cov0" title="0">{
        for _, rt := range routes </span><span class="cov0" title="0">{
                if rt.method != strings.ToUpper(method) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">pathVars, ok := matchPattern(rt.pattern, path)
                if ok </span><span class="cov0" title="0">{
                        return &amp;rt, pathVars
                }</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

// matchPattern recibe un pattern (ej "/users/:id") y un path ("/users/123").
// Retorna (mapDeVariables, true) si matchea, o (nil, false) si no.
func matchPattern(pattern, path string) (map[string]string, bool) <span class="cov0" title="0">{
        // Dividimos por "/", comparamos fragmentos. Los ":" se interpretan como variable.
        patParts := strings.Split(pattern, "/")
        pathParts := strings.Split(path, "/")

        if len(patParts) != len(pathParts) </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">vars := make(map[string]string)
        for i := 0; i &lt; len(patParts); i++ </span><span class="cov0" title="0">{
                p := patParts[i]
                real := pathParts[i]
                if strings.HasPrefix(p, ":") </span><span class="cov0" title="0">{
                        // variable
                        varName := p[1:] // sin ':'
                        vars[varName] = real
                }</span> else<span class="cov0" title="0"> {
                        // literal
                        if p != real </span><span class="cov0" title="0">{
                                return nil, false
                        }</span>
                }
        }
        <span class="cov0" title="0">return vars, true</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package r2libs

import (
        "bytes"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "io"
        "net/http"
        "strings"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"
)

// r2httpclient.go: Funciones nativas de HTTP y JSON/XML en R2

func RegisterHTTPClient(env *r2core.Environment) <span class="cov0" title="0">{
        functions := map[string]r2core.BuiltinFunction{
                "clientHttpGet": r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("clientHttpGet necesita (url)")</span>
                        }
                        <span class="cov0" title="0">url, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("clientHttpGet: url debe ser string")</span>
                        }
                        <span class="cov0" title="0">resp, err := http.Get(url)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("clientHttpGet: error en GET '%s': %v", url, err))</span>
                        }
                        <span class="cov0" title="0">defer resp.Body.Close()
                        data, err := io.ReadAll(resp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("clientHttpGet: error al leer body: %v", err))</span>
                        }
                        <span class="cov0" title="0">return string(data)</span>
                }),

                "clientHttpPost": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("clientHttpPost necesita (url, bodyString)")</span>
                        }
                        <span class="cov0" title="0">url, ok1 := args[0].(string)
                        bodyStr, ok2 := args[1].(string)
                        if !ok1 || !ok2 </span><span class="cov0" title="0">{
                                panic("clientHttpPost: (url, bodyString) deben ser strings")</span>
                        }

                        <span class="cov0" title="0">resp, err := http.Post(url, "text/plain", bytes.NewBufferString(bodyStr))
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("clientHttpPost: error en POST '%s': %v", url, err))</span>
                        }
                        <span class="cov0" title="0">defer resp.Body.Close()
                        data, err := io.ReadAll(resp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("clientHttpPost: error al leer body: %v", err))</span>
                        }
                        <span class="cov0" title="0">return string(data)</span>
                }),

                "parseJSON": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("parseJSON necesita (jsonString)")</span>
                        }
                        <span class="cov0" title="0">js, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("parseJSON: argumento debe ser string JSON")</span>
                        }
                        <span class="cov0" title="0">var result interface{}
                        err := json.Unmarshal([]byte(js), &amp;result)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("parseJSON: error al parsear JSON: %v", err))</span>
                        }
                        // result puede ser map[string]interface{} o []interface{}
                        <span class="cov0" title="0">return result</span>
                }),

                "stringifyJSON": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("stringifyJSON necesita (value)")</span>
                        }
                        <span class="cov0" title="0">val := args[0]
                        // val debería ser un map[string]interface{} o []interface{} (o algo anidable)
                        data, err := json.Marshal(val)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("stringifyJSON: error al serializar: %v", err))</span>
                        }
                        <span class="cov0" title="0">return string(data)</span>
                }),

                "clientHttpGetJSON": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("httpGetJSON necesita (url)")</span>
                        }
                        <span class="cov0" title="0">url, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("httpGetJSON: url debe ser string")</span>
                        }
                        <span class="cov0" title="0">resp, err := http.Get(url)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("httpGetJSON: error en GET '%s': %v", url, err))</span>
                        }
                        <span class="cov0" title="0">defer resp.Body.Close()
                        data, err := io.ReadAll(resp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("httpGetJSON: error al leer body: %v", err))</span>
                        }
                        <span class="cov0" title="0">var result interface{}
                        if err := json.Unmarshal(data, &amp;result); err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("httpGetJSON: error al parsear JSON: %v", err))</span>
                        }
                        <span class="cov0" title="0">return result</span>
                }),

                "clientHttpPostJSON": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("httpPostJSON necesita (url, value)")</span>
                        }
                        <span class="cov0" title="0">url, ok1 := args[0].(string)
                        val := args[1] // supuestamente map/array
                        if !ok1 </span><span class="cov0" title="0">{
                                panic("httpPostJSON: url debe ser string")</span>
                        }

                        // Serializamos 'val' a JSON
                        <span class="cov0" title="0">jsData, err := json.Marshal(val)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("httpPostJSON: error al serializar: %v", err))</span>
                        }

                        <span class="cov0" title="0">resp, err := http.Post(url, "application/json", bytes.NewReader(jsData))
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("httpPostJSON: error en POST '%s': %v", url, err))</span>
                        }
                        <span class="cov0" title="0">defer resp.Body.Close()
                        respData, err := io.ReadAll(resp.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("httpPostJSON: error al leer respuesta: %v", err))</span>
                        }

                        <span class="cov0" title="0">var result interface{}
                        if err := json.Unmarshal(respData, &amp;result); err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("httpPostJSON: error al parsear respuesta JSON: %v", err))</span>
                        }
                        <span class="cov0" title="0">return result</span>
                }),

                "parseXML": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("parseXML necesita (xmlString)")</span>
                        }
                        <span class="cov0" title="0">s, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("parseXML: argumento debe ser string con XML")</span>
                        }
                        <span class="cov0" title="0">var root xmlNode
                        err := xml.Unmarshal([]byte(s), &amp;root)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("parseXML: error al parsear XML: %v", err))</span>
                        }
                        // Convertimos xmlNode -&gt; map[string]interface{}
                        <span class="cov0" title="0">return xmlNodeToMap(&amp;root)</span>
                }),

                "stringifyXML": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("stringifyXML necesita (value)")</span>
                        }
                        <span class="cov0" title="0">valMap, ok := args[0].(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                panic("stringifyXML: se esperaba un map[string]interface{}")</span>
                        }
                        // Podrías tener un "root" con subvalores, etc.
                        // Aquí supongo que el map tiene 1 root key
                        <span class="cov0" title="0">if len(valMap) != 1 </span><span class="cov0" title="0">{
                                panic("stringifyXML: se espera un map con un root key")</span>
                        }

                        // Tomamos la primera key como root
                        <span class="cov0" title="0">var rootKey string
                        var rootVal interface{}
                        for k, v := range valMap </span><span class="cov0" title="0">{
                                rootKey = k
                                rootVal = v
                                break</span>
                        }
                        // Construimos un xmlNode
                        <span class="cov0" title="0">node := mapToXMLNode(rootKey, rootVal)
                        out, err := xml.MarshalIndent(node, "", "  ")
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("stringifyXML: error al serializar: %v", err))</span>
                        }
                        // xml.Marshal produce &lt;xmlNode&gt; algo ... &lt;/xmlNode&gt;
                        // Si queremos algo más refinado, habría que personalizar.
                        <span class="cov0" title="0">return string(out)</span>
                }),
        }
        
        <span class="cov0" title="0">RegisterModule(env, "httpclient", functions)</span>
}

//===========================================================
// Estructuras de ayuda para parseXML / stringifyXML
//===========================================================

// xmlNode define un nodo genérico para decodificar XML
type xmlNode struct {
        XMLName  xml.Name   `xml:""`
        Content  string     `xml:",chardata"`
        Children []xmlNode  `xml:",any"`
        Attrs    []xml.Attr `xml:",any,attr"`
}

func xmlNodeToMap(n *xmlNode) interface{} <span class="cov0" title="0">{
        // Cada nodo se representa como un map con keys: "_name", "_content", "_attrs", "childName", ...
        m := make(map[string]interface{})
        // Nombre
        m["_name"] = n.XMLName.Local
        // Contenido textual (si hay)
        trimC := strings.TrimSpace(n.Content)
        if trimC != "" </span><span class="cov0" title="0">{
                m["_content"] = trimC
        }</span>
        // Atributos
        <span class="cov0" title="0">if len(n.Attrs) &gt; 0 </span><span class="cov0" title="0">{
                attrsMap := make(map[string]interface{})
                for _, at := range n.Attrs </span><span class="cov0" title="0">{
                        attrsMap[at.Name.Local] = at.Value
                }</span>
                <span class="cov0" title="0">m["_attrs"] = attrsMap</span>
        }
        // Hijos
        <span class="cov0" title="0">for _, c := range n.Children </span><span class="cov0" title="0">{
                childName := c.XMLName.Local
                childVal := xmlNodeToMap(&amp;c)
                // Podríamos agrupar por nombre, si hay múltiples hijos con el mismo
                // para simplicidad, se hace m[childName] = childVal si no existe,
                // o se convierte en array si hay más de 1
                existing, found := m[childName]
                if !found </span><span class="cov0" title="0">{
                        m[childName] = childVal
                }</span> else<span class="cov0" title="0"> {
                        // si ya hay uno =&gt; array
                        switch arr := existing.(type) </span>{
                        case []interface{}:<span class="cov0" title="0">
                                m[childName] = append(arr, childVal)</span>
                        default:<span class="cov0" title="0">
                                // convertimos en array
                                m[childName] = []interface{}{arr, childVal}</span>
                        }
                }
        }
        <span class="cov0" title="0">return m</span>
}

// mapToXMLNode crea un xmlNode a partir de un map con keys
func mapToXMLNode(name string, val interface{}) xmlNode <span class="cov0" title="0">{
        node := xmlNode{XMLName: xml.Name{Local: name}}
        // val puede ser map[string]interface{} =&gt; interpretamos subnodos
        switch mm := val.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                // si hay "_content"
                if c, ok := mm["_content"]; ok </span><span class="cov0" title="0">{
                        node.Content = fmt.Sprint(c)
                }</span>
                // si hay "_attrs"
                <span class="cov0" title="0">if a, ok := mm["_attrs"]; ok </span><span class="cov0" title="0">{
                        if attrMap, ok2 := a.(map[string]interface{}); ok2 </span><span class="cov0" title="0">{
                                for k, v := range attrMap </span><span class="cov0" title="0">{
                                        node.Attrs = append(node.Attrs, xml.Attr{Name: xml.Name{Local: k}, Value: fmt.Sprint(v)})
                                }</span>
                        }
                }
                // para cada key, si no es "_content", "_attrs", "_name", se interpretan como hijos
                <span class="cov0" title="0">for k, v := range mm </span><span class="cov0" title="0">{
                        if k == "_content" || k == "_attrs" || k == "_name" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // Si v es array =&gt; múltiples subnodos
                        <span class="cov0" title="0">switch arr := v.(type) </span>{
                        case []interface{}:<span class="cov0" title="0">
                                for _, elem := range arr </span><span class="cov0" title="0">{
                                        subNode := mapToXMLNode(k, elem)
                                        node.Children = append(node.Children, subNode)
                                }</span>
                        default:<span class="cov0" title="0">
                                // un solo nodo
                                subNode := mapToXMLNode(k, arr)
                                node.Children = append(node.Children, subNode)</span>
                        }
                }
        default:<span class="cov0" title="0">
                // si val es string / número =&gt; lo ponemos en _content
                node.Content = fmt.Sprint(val)</span>
        }
        <span class="cov0" title="0">return node</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package r2libs

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"
)

// r2io.go: Manejo de archivos e I/O en tu lenguaje R2

func RegisterIO(env *r2core.Environment) <span class="cov8" title="1">{
        functions := map[string]r2core.BuiltinFunction{
                "readFile": r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("readFile necesita (path)")</span>
                        }
                        <span class="cov0" title="0">path, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("readFile: primer argumento debe ser string (path)")</span>
                        }
                        <span class="cov0" title="0">data, err := os.ReadFile(path)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("readFile: error al leer '%s': %v", path, err))</span>
                        }
                        <span class="cov0" title="0">return string(data)</span>
                }),

                "writeFile": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("writeFile necesita 2 argumentos: (path, contents)")</span>
                        }
                        <span class="cov0" title="0">path, ok1 := args[0].(string)
                        contents, ok2 := args[1].(string)
                        if !ok1 || !ok2 </span><span class="cov0" title="0">{
                                panic("writeFile: (path, contents) deben ser strings")</span>
                        }
                        <span class="cov0" title="0">err := os.WriteFile(path, []byte(contents), 0644)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("writeFile: error al escribir '%s': %v", path, err))</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }),

                "appendFile": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("appendFile necesita (path, contents)")</span>
                        }
                        <span class="cov0" title="0">path, ok1 := args[0].(string)
                        contents, ok2 := args[1].(string)
                        if !ok1 || !ok2 </span><span class="cov0" title="0">{
                                panic("appendFile: (path, contents) deben ser strings")</span>
                        }

                        <span class="cov0" title="0">f, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("appendFile: error al abrir '%s': %v", path, err))</span>
                        }
                        <span class="cov0" title="0">defer f.Close()

                        _, err = f.WriteString(contents)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("appendFile: error al escribir en '%s': %v", path, err))</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }),

                "removeFile": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("removeFile necesita (path)")</span>
                        }
                        <span class="cov0" title="0">path, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("removeFile: path debe ser string")</span>
                        }
                        <span class="cov0" title="0">err := os.Remove(path)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("removeFile: error al borrar '%s': %v", path, err))</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }),

                "renameFile": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("renameFile necesita (oldPath, newPath)")</span>
                        }
                        <span class="cov0" title="0">oldP, ok1 := args[0].(string)
                        newP, ok2 := args[1].(string)
                        if !ok1 || !ok2 </span><span class="cov0" title="0">{
                                panic("renameFile: (oldPath, newPath) deben ser strings")</span>
                        }
                        <span class="cov0" title="0">err := os.Rename(oldP, newP)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("renameFile: error al renombrar '%s' a '%s': %v", oldP, newP, err))</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }),

                "readDir": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("readDir necesita (path)")</span>
                        }
                        <span class="cov0" title="0">dir, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("readDir: path debe ser string")</span>
                        }
                        <span class="cov0" title="0">files, err := os.ReadDir(dir)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("readDir: error al leer directorio '%s': %v", dir, err))</span>
                        }
                        <span class="cov0" title="0">var result []interface{}
                        for _, f := range files </span><span class="cov0" title="0">{
                                // Ej: "archivo.txt" o "subcarpeta"
                                result = append(result, f.Name())
                        }</span>
                        <span class="cov0" title="0">return result</span>
                }),

                "makeDir": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("makeDir necesita (path)")</span>
                        }
                        <span class="cov0" title="0">dir, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("makeDir: path debe ser string")</span>
                        }
                        <span class="cov0" title="0">err := os.Mkdir(dir, 0755)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("makeDir: error al crear directorio '%s': %v", dir, err))</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }),

                "makeDirs": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("makeDirs necesita (path)")</span>
                        }
                        <span class="cov0" title="0">dir, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("makeDirs: path debe ser string")</span>
                        }
                        <span class="cov0" title="0">err := os.MkdirAll(dir, 0755)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("makeDirs: error al crear directorios '%s': %v", dir, err))</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }),

                "absPath": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("absPath necesita (path)")</span>
                        }
                        <span class="cov0" title="0">p, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("absPath: path debe ser string")</span>
                        }
                        <span class="cov0" title="0">abs, err := filepath.Abs(p)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("absPath: error con '%s': %v", p, err))</span>
                        }
                        <span class="cov0" title="0">return abs</span>
                }),

                "fileExists": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("fileExists necesita (path)")</span>
                        }
                        <span class="cov0" title="0">p, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("fileExists: path debe ser string")</span>
                        }
                        <span class="cov0" title="0">_, err := os.Stat(p)
                        return !os.IsNotExist(err)</span>
                }),
        }

        <span class="cov8" title="1">RegisterModule(env, "io", functions)</span>
}</pre>
		
		<pre class="file" id="file11" style="display: none">package r2libs

import (
        "fmt"
        "sort"
)

// Graph represents a directed graph for knowledge representation.
type Graph struct {
        Edges      map[string][]string
        Debug      bool
        ReverseMap map[string][]string // Cached reverse edges for efficient descendant queries
}

// NewGraph initializes a new graph.
func NewGraph() *Graph <span class="cov8" title="1">{
        return &amp;Graph{
                Edges:      make(map[string][]string),
                ReverseMap: make(map[string][]string),
        }
}</span>

// EnableDebug enables debug mode.
func (g *Graph) EnableDebug() <span class="cov0" title="0">{
        g.Debug = true
}</span>

// AddEdge adds a directed edge to the graph.
func (g *Graph) AddEdge(from, to string) <span class="cov8" title="1">{
        g.Edges[from] = append(g.Edges[from], to)
        g.ReverseMap[to] = append(g.ReverseMap[to], from)
        if g.Debug </span><span class="cov0" title="0">{
                fmt.Printf("Added edge: %s -&gt; %s\n", from, to)
        }</span>
}

// AddBidirectionalEdge adds a bidirectional edge.
func (g *Graph) AddBidirectionalEdge(node1, node2 string) <span class="cov0" title="0">{
        g.AddEdge(node1, node2)
        g.AddEdge(node2, node1)
}</span>

// GetAncestors finds all ancestors of a node using DFS.
func (g *Graph) GetAncestors(node string) []string <span class="cov8" title="1">{
        visited := make(map[string]bool)
        var result []string
        g.dfs(node, visited, &amp;result, g.ReverseMap)
        return result
}</span>

// GetDescendants finds all descendants of a node using DFS.
func (g *Graph) GetDescendants(node string) []string <span class="cov8" title="1">{
        visited := make(map[string]bool)
        var result []string
        g.dfs(node, visited, &amp;result, g.Edges)
        return result
}</span>

// GetRelationshipLevel finds the shortest distance between two nodes.
func (g *Graph) GetRelationshipLevel(start, end string) int <span class="cov8" title="1">{
        queue := []string{start}
        visited := make(map[string]bool)
        levels := make(map[string]int)

        levels[start] = 0
        visited[start] = true

        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                current := queue[0]
                queue = queue[1:]

                for _, neighbor := range g.Edges[current] </span><span class="cov8" title="1">{
                        if !visited[neighbor] </span><span class="cov8" title="1">{
                                visited[neighbor] = true
                                levels[neighbor] = levels[current] + 1
                                if neighbor == end </span><span class="cov8" title="1">{
                                        return levels[neighbor]
                                }</span>
                                <span class="cov8" title="1">queue = append(queue, neighbor)</span>
                        }
                }
        }

        <span class="cov8" title="1">return -1</span> // Return -1 if nodes are not related
}

// GetShortestPath finds the shortest path between two nodes using BFS.
func (g *Graph) GetShortestPath(start, end string) []string <span class="cov8" title="1">{
        queue := [][]string{{start}}
        visited := make(map[string]bool)
        visited[start] = true

        for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                path := queue[0]
                queue = queue[1:]

                node := path[len(path)-1]
                if node == end </span><span class="cov8" title="1">{
                        return path
                }</span>

                <span class="cov8" title="1">for _, neighbor := range g.Edges[node] </span><span class="cov8" title="1">{
                        if !visited[neighbor] </span><span class="cov8" title="1">{
                                visited[neighbor] = true
                                newPath := append([]string{}, path...)
                                newPath = append(newPath, neighbor)
                                queue = append(queue, newPath)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span> // Return nil if no path exists
}

// dfs is a helper function for depth-first search.

func (g *Graph) dfs(node string, visited map[string]bool, result *[]string, edges map[string][]string) <span class="cov8" title="1">{
        neighbors := edges[node]
        sort.Strings(neighbors) // Ordenar los vecinos
        for _, neighbor := range neighbors </span><span class="cov8" title="1">{
                if !visited[neighbor] </span><span class="cov8" title="1">{
                        visited[neighbor] = true
                        *result = append(*result, neighbor)
                        g.dfs(neighbor, visited, result, edges)
                }</span>
        }
}

/*
// Example usage
func init() {
        graph := NewGraph()
        graph.EnableDebug()

        // Add facts as edges
        graph.AddEdge("Federico", "Elias")
        graph.AddEdge("Federico", "Eugenia")
        graph.AddEdge("Elias", "Sara")
        graph.AddEdge("Elias", "Arturo")
        graph.AddEdge("Sara", "Telma")

        // Query ancestors
        queryNode := "Sara"
        fmt.Printf("\nAncestors of %s:\n", queryNode)
        ancestors := graph.GetAncestors(queryNode)
        fmt.Println(ancestors)

        // Query descendants
        fmt.Printf("\nDescendants of %s:\n", queryNode)
        descendants := graph.GetDescendants(queryNode)
        fmt.Println(descendants)

        // Check relationship level
        fmt.Printf("\nRelationship level between Federico and Telma:\n")
        level := graph.GetRelationshipLevel("Federico", "Telma")
        fmt.Println(level)

        // Find shortest path
        fmt.Printf("\nShortest path between Federico and Telma:\n")
        path := graph.GetShortestPath("Federico", "Telma")
        fmt.Println(path)
}

//*/
</pre>
		
		<pre class="file" id="file12" style="display: none">package r2libs

import (
        "fmt"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"
)

func RegisterLib(env *r2core.Environment) <span class="cov0" title="0">{
        builtins := map[string]r2core.BuiltinFunction{
                "print": func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                        for _, a := range args </span><span class="cov0" title="0">{
                                fmt.Print(a, " ")
                        }</span>
                        <span class="cov0" title="0">fmt.Println()
                        return nil</span>
                },

                "r2": func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("r2 need at least one function as argument")</span>
                        }
                        // Verificar que el primer argumento sea una función
                        <span class="cov0" title="0">fn, ok := args[0].(*r2core.UserFunction)
                        if !ok </span><span class="cov0" title="0">{
                                panic("r2 first argument must be a function")</span>
                        }
                        <span class="cov0" title="0">r2core.Add()
                        // Ejecutar la función en una goroutine
                        go func() </span><span class="cov0" title="0">{
                                defer r2core.Done()
                                defer func() </span><span class="cov0" title="0">{
                                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                fmt.Println("Error en goroutine:", r)
                                        }</span>
                                }()
                                <span class="cov0" title="0">fn.Call(args[1:]...)</span>
                        }()
                        <span class="cov0" title="0">return nil</span>
                },

                "go": func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("go need at least one function as argument")</span>
                        }
                        // Verificar que el primer argumento sea una función
                        <span class="cov0" title="0">fn, ok := args[0].(*r2core.UserFunction)
                        if !ok </span><span class="cov0" title="0">{
                                panic("go first argument must be a function")</span>
                        }
                        // Ejecutar la función en una goroutine
                        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                                fn.Call(args[1:]...)
                        }</span>()
                        <span class="cov0" title="0">return nil</span>
                },
        }
        <span class="cov0" title="0">for name, fn := range builtins </span><span class="cov0" title="0">{
                env.Set(name, fn)
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package r2libs

import (
        "math"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"
)

// r2math.go: Funciones matemáticas para R2

func RegisterMath(env *r2core.Environment) <span class="cov8" title="1">{
        functions := map[string]r2core.BuiltinFunction{
                "sin": r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("sin needs (number)")</span>
                        }
                        <span class="cov8" title="1">x := toFloat(args[0])
                        return math.Sin(x)</span>
                }),

                "cos": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("cos  needs (number)")</span>
                        }
                        <span class="cov0" title="0">x := toFloat(args[0])
                        return math.Cos(x)</span>
                }),

                "tan": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("tan needs (number)")</span>
                        }
                        <span class="cov0" title="0">x := toFloat(args[0])
                        return math.Tan(x)</span>
                }),

                "sqrt": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("sqrt needs (number)")</span>
                        }
                        <span class="cov0" title="0">x := toFloat(args[0])
                        if x &lt; 0 </span><span class="cov0" title="0">{
                                panic("sqrt: could not calculate square root of negative number")</span>
                        }
                        <span class="cov0" title="0">return math.Sqrt(x)</span>
                }),

                "pow": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("pow needs (base, exp)")</span>
                        }
                        <span class="cov0" title="0">base := toFloat(args[0])
                        exp := toFloat(args[1])
                        return math.Pow(base, exp)</span>
                }),

                "log": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("log needs (number)")</span>
                        }
                        <span class="cov0" title="0">x := toFloat(args[0])
                        if x &lt;= 0 </span><span class="cov0" title="0">{
                                panic("log: could not calculate log of zero or negative number")</span>
                        }
                        <span class="cov0" title="0">return math.Log(x)</span>
                }),

                "log10": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("log10 needs (number)")</span>
                        }
                        <span class="cov0" title="0">x := toFloat(args[0])
                        if x &lt;= 0 </span><span class="cov0" title="0">{
                                panic("log10: could not calculate log of zero or negative number")</span>
                        }
                        <span class="cov0" title="0">return math.Log10(x)</span>
                }),

                "exp": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("exp needs (number)")</span>
                        }
                        <span class="cov0" title="0">x := toFloat(args[0])
                        return math.Exp(x)</span>
                }),

                "abs": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("abs needs (number)")</span>
                        }
                        <span class="cov0" title="0">x := toFloat(args[0])
                        return math.Abs(x)</span>
                }),

                "floor": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("floor needs (number)")</span>
                        }
                        <span class="cov0" title="0">x := toFloat(args[0])
                        return math.Floor(x)</span>
                }),

                "ceil": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("ceil needs (number)")</span>
                        }
                        <span class="cov0" title="0">x := toFloat(args[0])
                        return math.Ceil(x)</span>
                }),

                "round": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("round needs (number)")</span>
                        }
                        <span class="cov0" title="0">x := toFloat(args[0])
                        return math.Round(x)</span>
                }),

                "max": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("max needs (a, b)")</span>
                        }
                        <span class="cov0" title="0">a := toFloat(args[0])
                        b := toFloat(args[1])
                        return math.Max(a, b)</span>
                }),

                "min": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("min needs (a, b)")</span>
                        }
                        <span class="cov0" title="0">a := toFloat(args[0])
                        b := toFloat(args[1])
                        return math.Min(a, b)</span>
                }),

                "hypot": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("hypot needs (x, y)")</span>
                        }
                        <span class="cov0" title="0">x := toFloat(args[0])
                        y := toFloat(args[1])
                        return math.Hypot(x, y)</span>
                }),
        }

        <span class="cov8" title="1">RegisterModule(env, "math", functions)

        // Register constants directly in the environment
        env.Set("PI", float64(math.Pi))
        env.Set("E", float64(math.E))</span>
}</pre>
		
		<pre class="file" id="file14" style="display: none">package r2libs

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"
)

// r2os.go: Funciones nativas para interactuar con el Sistema Operativo.
// Incluye manejo de procesos (exec, background process, etc.).

// Estructura para guardar referencia a un proceso lanzado en background
type R2Process struct {
        cmd    *exec.Cmd
        killed bool
}

// R2Process Eval =&gt; no hace nada, solo devolvemos algo representativo
func (rp *R2Process) Eval(env *r2core.Environment) interface{} <span class="cov0" title="0">{
        return rp // se podría devolver la misma referencia
}</span>

func RegisterOS(env *r2core.Environment) <span class="cov8" title="1">{
        functions := map[string]r2core.BuiltinFunction{
                "exit": r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                os.Exit(0)
                        }</span>
                        <span class="cov0" title="0">code, ok := args[0].(int)
                        if !ok </span><span class="cov0" title="0">{
                                panic("exit: arg should be int")</span>
                        }
                        <span class="cov0" title="0">os.Exit(code)
                        return nil</span>
                }),

                "osName": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        // Ejemplo: en Windows a veces "Windows_NT", en Linux no siempre está OS
                        // Podrías usar "runtime.GOOS" si deseas algo confiable en Go:
                        // return runtime.GOOS
                        val, found := os.LookupEnv("OS")
                        if !found || val == "" </span><span class="cov0" title="0">{
                                return "unknown"
                        }</span>
                        <span class="cov0" title="0">return val</span>
                }),

                "currentDir": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        dir, err := os.Getwd()
                        if err != nil </span><span class="cov0" title="0">{
                                panic("currentDir: error " + err.Error())</span>
                        }
                        <span class="cov0" title="0">return dir</span>
                }),

                "chDir": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("chDir necesita (path)")</span>
                        }
                        <span class="cov0" title="0">path, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("chDir: arg debe ser string")</span>
                        }
                        <span class="cov0" title="0">err := os.Chdir(path)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("chDir: error cambiando a '%s': %v", path, err))</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }),

                "setEnv": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("setEnv(key, value)")</span>
                        }
                        <span class="cov0" title="0">k, ok1 := args[0].(string)
                        v, ok2 := args[1].(string)
                        if !(ok1 &amp;&amp; ok2) </span><span class="cov0" title="0">{
                                panic("setEnv: (string, string)")</span>
                        }
                        <span class="cov0" title="0">err := os.Setenv(k, v)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("setEnv: error =&gt; %v", err))</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }),

                "getEnv": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("getEnv(key)")</span>
                        }
                        <span class="cov0" title="0">k, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("getEnv: arg debe ser string")</span>
                        }
                        <span class="cov0" title="0">val, found := os.LookupEnv(k)
                        if !found </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return val</span>
                }),

                "envList": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        vars := os.Environ()
                        m := make(map[string]interface{})
                        for _, kv := range vars </span><span class="cov0" title="0">{
                                parts := strings.SplitN(kv, "=", 2)
                                if len(parts) == 2 </span><span class="cov0" title="0">{
                                        m[parts[0]] = parts[1]
                                }</span>
                        }
                        <span class="cov0" title="0">return m</span>
                }),

                "listDir": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("listDir(path)")</span>
                        }
                        <span class="cov0" title="0">path, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("listDir: arg should be string")</span>
                        }
                        <span class="cov0" title="0">f, err := os.Open(path)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("listDir: error '%s': %v", path, err))</span>
                        }
                        <span class="cov0" title="0">defer f.Close()
                        names, err := f.Readdirnames(-1)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("listDir: error reading '%s': %v", path, err))</span>
                        }
                        <span class="cov0" title="0">arr := make([]interface{}, len(names))
                        for i, nm := range names </span><span class="cov0" title="0">{
                                arr[i] = nm
                        }</span>
                        <span class="cov0" title="0">return arr</span>
                }),

                "absPath": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("absPath needs (path)")</span>
                        }
                        <span class="cov0" title="0">path, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("absPath: arg should be string")</span>
                        }
                        <span class="cov0" title="0">abs, err := filepath.Abs(path)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("absPath: error =&gt; %v", err))</span>
                        }
                        <span class="cov0" title="0">return abs</span>
                }),

                "execCmd": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("execCmd(cmdString)")</span>
                        }
                        <span class="cov0" title="0">cmdLine, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("execCmd: arg should be string")</span>
                        }
                        <span class="cov0" title="0">out, err := exec.Command("sh", "-c", cmdLine).CombinedOutput()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Sprintf("Error:%v\nOutput:\n%s", err, out)
                        }</span>
                        <span class="cov0" title="0">return string(out)</span>
                }),

                "runProcess": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("runProcess(cmdString)")</span>
                        }
                        <span class="cov0" title="0">cmdLine, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("runProcess: arg debe ser string")</span>
                        }
                        // parse: naive approach =&gt; "sh -c &lt;cmd&gt;"
                        <span class="cov0" title="0">cmd := exec.Command("sh", "-c", cmdLine)
                        // Iniciar
                        err := cmd.Start()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Sprintf("Error al iniciar '%s': %v", cmdLine, err)
                        }</span>
                        // Creamos R2Process
                        <span class="cov0" title="0">rp := &amp;R2Process{cmd: cmd}
                        return rp</span>
                }),

                "waitProcess": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("waitProcess needs (r2proc)")</span>
                        }
                        <span class="cov0" title="0">rp, ok := args[0].(*R2Process)
                        if !ok </span><span class="cov0" title="0">{
                                panic("waitProcess: arg is not an R2Process")</span>
                        }
                        <span class="cov0" title="0">if rp.killed </span><span class="cov0" title="0">{
                                return "error:The process was already kill()ed.."
                        }</span>
                        <span class="cov0" title="0">err := rp.cmd.Wait()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Sprintf("error:Process ended with an error: %v", err)
                        }</span>
                        <span class="cov0" title="0">return "success"</span>
                }),

                "killProcess": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("killProcess(r2proc)")</span>
                        }
                        <span class="cov0" title="0">rp, ok := args[0].(*R2Process)
                        if !ok </span><span class="cov0" title="0">{
                                panic("killProcess: arg is not an R2Process")</span>
                        }
                        <span class="cov0" title="0">if rp.killed </span><span class="cov0" title="0">{
                                return nil // ya kill
                        }</span>
                        <span class="cov0" title="0">err := rp.cmd.Process.Kill()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Sprintf("Error kill =&gt; %v", err)
                        }</span>
                        <span class="cov0" title="0">rp.killed = true
                        return nil</span>
                }),
        }
        
        <span class="cov8" title="1">RegisterModule(env, "os", functions)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package r2libs

import (
        "encoding/json"
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"
        // Podrías importar alguna librería de colores (ej. "github.com/fatih/color") si quieres
)

// r2print.go: Funciones de impresión avanzadas para R2

func RegisterPrint(env *r2core.Environment) <span class="cov8" title="1">{
        functions := map[string]r2core.BuiltinFunction{
                "printRepeat": r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("printRepeat needs (str, count)")</span>
                        }
                        <span class="cov0" title="0">s, ok1 := args[0].(string)
                        count := int(toFloat(args[1]))
                        if !ok1 </span><span class="cov0" title="0">{
                                panic("printRepeat: primer arg should be string")</span>
                        }
                        <span class="cov0" title="0">for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                                fmt.Print(s)
                        }</span>
                        <span class="cov0" title="0">fmt.Println() // salto de línea
                        return nil</span>
                }),

                "printBox": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("printBox needs (str, width)")</span>
                        }
                        <span class="cov0" title="0">text, ok1 := args[0].(string)
                        width := int(toFloat(args[1]))
                        if !ok1 </span><span class="cov0" title="0">{
                                panic("printBox: first arg should be string")</span>
                        }
                        <span class="cov0" title="0">if width &lt; len(text)+2 </span><span class="cov0" title="0">{
                                width = len(text) + 2
                        }</span>
                        // Cabecera
                        <span class="cov0" title="0">fmt.Println("+" + strings.Repeat("-", width) + "+")
                        // Texto centrado
                        space := width - len(text)
                        leftPad := space / 2
                        rightPad := space - leftPad
                        fmt.Printf("|%s%s%s|\n", strings.Repeat(" ", leftPad), text, strings.Repeat(" ", rightPad))
                        // Pie
                        fmt.Println("+" + strings.Repeat("-", width) + "+")
                        return nil</span>
                }),

                "debugInspect": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("debugInspect needs (value)")</span>
                        }
                        <span class="cov0" title="0">val := args[0]
                        fmt.Printf("[debugInspect] Value = %v (type=%T)\n", val, val)
                        return nil</span>
                }),

                "printColor": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("printColor(str, colorName)")</span>
                        }
                        <span class="cov0" title="0">txt, ok1 := args[0].(string)
                        colorName, ok2 := args[1].(string)
                        if !(ok1 &amp;&amp; ok2) </span><span class="cov0" title="0">{
                                panic("printColor: (string, string)")</span>
                        }
                        <span class="cov0" title="0">colorCode := ""
                        switch strings.ToLower(colorName) </span>{
                        case "red":<span class="cov0" title="0">
                                colorCode = "\033[31m"</span>
                        case "green":<span class="cov0" title="0">
                                colorCode = "\033[32m"</span>
                        case "yellow":<span class="cov0" title="0">
                                colorCode = "\033[33m"</span>
                        case "blue":<span class="cov0" title="0">
                                colorCode = "\033[34m"</span>
                        case "reset":<span class="cov0" title="0">
                                colorCode = "\033[0m"</span>
                        default:<span class="cov0" title="0">
                                colorCode = "\033[0m"</span> // reset
                        }
                        // Imprimir con color, y reset al final
                        <span class="cov0" title="0">fmt.Print(colorCode, txt, "\033[0m\n")
                        return nil</span>
                }),

                "printProgress": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 3 </span><span class="cov0" title="0">{
                                panic("printProgress(label, totalSteps, stepDelayMs)")</span>
                        }
                        <span class="cov0" title="0">label, ok1 := args[0].(string)
                        total := int(toFloat(args[1]))
                        delayMs := int(toFloat(args[2]))
                        if !ok1 </span><span class="cov0" title="0">{
                                panic("printProgress: label debe ser string")</span>
                        }
                        // Cada step, imprime algo
                        <span class="cov0" title="0">for i := 0; i &lt;= total; i++ </span><span class="cov0" title="0">{
                                pct := float64(i) / float64(total) * 100.0
                                bar := strings.Repeat("#", i) + strings.Repeat(" ", total-i)
                                fmt.Printf("\r%s [%s] %.0f%%", label, bar, pct)
                                time.Sleep(time.Duration(delayMs) * time.Millisecond)
                        }</span>
                        <span class="cov0" title="0">fmt.Println() // salto línea final
                        return nil</span>
                }),

                "printTable": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("printTable necesita (arrayOfArrays)")</span>
                        }
                        <span class="cov0" title="0">rows, ok := args[0].([]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                panic("printTable: primer arg debe ser array (cada elem =&gt; array celdas)")</span>
                        }
                        // Calcular anchos máximos por columna
                        // 1) averiguar cuántas columnas máximo
                        <span class="cov0" title="0">maxCols := 0
                        tableData := make([][]string, len(rows))
                        for i, row := range rows </span><span class="cov0" title="0">{
                                rowArr, ok2 := row.([]interface{})
                                if !ok2 </span><span class="cov0" title="0">{
                                        panic("printTable: cada fila debe ser un array")</span>
                                }
                                <span class="cov0" title="0">tableData[i] = make([]string, len(rowArr))
                                if len(rowArr) &gt; maxCols </span><span class="cov0" title="0">{
                                        maxCols = len(rowArr)
                                }</span>
                                // convertir a string
                                <span class="cov0" title="0">for j, cell := range rowArr </span><span class="cov0" title="0">{
                                        tableData[i][j] = fmt.Sprint(cell)
                                }</span>
                        }
                        // 2) ancho máximo por columna
                        <span class="cov0" title="0">colWidths := make([]int, maxCols)
                        for i := 0; i &lt; len(tableData); i++ </span><span class="cov0" title="0">{
                                for j := 0; j &lt; len(tableData[i]); j++ </span><span class="cov0" title="0">{
                                        cellLen := len(tableData[i][j])
                                        if cellLen &gt; colWidths[j] </span><span class="cov0" title="0">{
                                                colWidths[j] = cellLen
                                        }</span>
                                }
                        }
                        // 3) imprimir
                        <span class="cov0" title="0">for i := 0; i &lt; len(tableData); i++ </span><span class="cov0" title="0">{
                                row := tableData[i]
                                for j := 0; j &lt; len(row); j++ </span><span class="cov0" title="0">{
                                        fmt.Printf("%-*s ", colWidths[j], row[j])
                                }</span>
                                <span class="cov0" title="0">fmt.Println()</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }),

                "printAlign": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 3 </span><span class="cov0" title="0">{
                                panic("printAlign(str, align, width)")</span>
                        }
                        <span class="cov0" title="0">s, ok1 := args[0].(string)
                        alignOpt, ok2 := args[1].(string)
                        width := int(toFloat(args[2]))
                        if !(ok1 &amp;&amp; ok2) </span><span class="cov0" title="0">{
                                panic("printAlign: (string, align, width)")</span>
                        }
                        <span class="cov0" title="0">if width &lt; len(s) </span><span class="cov0" title="0">{
                                width = len(s)
                        }</span>
                        <span class="cov0" title="0">space := width - len(s)
                        switch strings.ToLower(alignOpt) </span>{
                        case "left":<span class="cov0" title="0">
                                // s + spaces
                                fmt.Println(s + strings.Repeat(" ", space))</span>
                        case "right":<span class="cov0" title="0">
                                // spaces + s
                                fmt.Println(strings.Repeat(" ", space) + s)</span>
                        case "center":<span class="cov0" title="0">
                                leftPad := space / 2
                                rightPad := space - leftPad
                                fmt.Println(strings.Repeat(" ", leftPad) + s + strings.Repeat(" ", rightPad))</span>
                        default:<span class="cov0" title="0">
                                panic("printAlign: align debe ser 'left','right' o 'center'")</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }),

                "println": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        for i, arg := range args </span><span class="cov0" title="0">{
                                if i &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Print(" ")
                                }</span>
                                <span class="cov0" title="0">fmt.Print(arg)</span>
                        }
                        <span class="cov0" title="0">fmt.Println()
                        return nil</span>
                }),

                "printf": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("printf necesita al menos un argumento: el formato")</span>
                        }
                        <span class="cov0" title="0">format, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("printf: el primer argumento debe ser una cadena de formato")</span>
                        }
                        <span class="cov0" title="0">var formatArgs []interface{}
                        if len(args) &gt; 1 </span><span class="cov0" title="0">{
                                formatArgs = args[1:]
                        }</span>
                        <span class="cov0" title="0">f, err := strconv.Unquote("\"" + format + "\"")
                        if err != nil </span><span class="cov0" title="0">{
                                panic("printf: error al parsear formato")</span>
                        }
                        <span class="cov0" title="0">fmt.Printf(f, formatArgs...)
                        return nil</span>
                }),

                "sprintf": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("printf necesita al menos un argumento: el formato")</span>
                        }
                        <span class="cov0" title="0">format, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("printf: el primer argumento debe ser una cadena de formato")</span>
                        }
                        <span class="cov0" title="0">var formatArgs []interface{}
                        if len(args) &gt; 1 </span><span class="cov0" title="0">{
                                formatArgs = args[1:]
                        }</span>
                        <span class="cov0" title="0">f, err := strconv.Unquote("\"" + format + "\"")
                        if err != nil </span><span class="cov0" title="0">{
                                panic("printf: error al parsear formato")</span>
                        }
                        <span class="cov0" title="0">return fmt.Sprintf(f, formatArgs...)</span>
                }),

                "sprint": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("sprint needs at least one argument")</span>
                        }
                        <span class="cov0" title="0">return fmt.Sprint(args...)</span>
                }),

                "printError": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("printError necesita (str)")</span>
                        }
                        <span class="cov0" title="0">str, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("printError: el argumento debe ser una cadena de texto")</span>
                        }
                        <span class="cov0" title="0">fmt.Println("\033[31m" + str + "\033[0m") // Rojo
                        return nil</span>
                }),

                "printWarning": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("printWarning necesita (str)")</span>
                        }
                        <span class="cov0" title="0">str, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("printWarning: el argumento debe ser una cadena de texto")</span>
                        }
                        <span class="cov0" title="0">fmt.Println("\033[33m" + str + "\033[0m") // Amarillo
                        return nil</span>
                }),

                "printSuccess": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("printSuccess necesita (str)")</span>
                        }
                        <span class="cov0" title="0">str, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("printSuccess: el argumento debe ser una cadena de texto")</span>
                        }
                        <span class="cov0" title="0">fmt.Println("\033[32m" + str + "\033[0m") // Verde
                        return nil</span>
                }),

                "printJSON": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("printJSON necesita (obj)")</span>
                        }
                        <span class="cov0" title="0">obj := args[0]
                        jsonBytes, err := json.MarshalIndent(obj, "", "  ")
                        if err != nil </span><span class="cov0" title="0">{
                                panic("printJSON: error al formatear JSON")</span>
                        }
                        <span class="cov0" title="0">fmt.Println(string(jsonBytes))
                        return nil</span>
                }),

                "clearScreen": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        // Código ANSI para limpiar la pantalla
                        fmt.Print("\033[H\033[2J")
                        return nil
                }</span>),

                "printTimestamp": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        currentTime := time.Now().Format(time.RFC1123)
                        fmt.Println(currentTime)
                        return nil
                }</span>),

                "printHeader": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("printHeader necesita (str)")</span>
                        }
                        <span class="cov0" title="0">str, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("printHeader: el argumento debe ser una cadena de texto")</span>
                        }
                        <span class="cov0" title="0">separator := strings.Repeat("=", len(str))
                        fmt.Println(separator)
                        fmt.Println(str)
                        fmt.Println(separator)
                        return nil</span>
                }),

                "printSeparator": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        width := 40 // Valor por defecto
                        if len(args) &gt;= 1 </span><span class="cov0" title="0">{
                                w, ok := args[0].(float64)
                                if !ok </span><span class="cov0" title="0">{
                                        panic("printSeparator: el argumento debe ser un número")</span>
                                }
                                <span class="cov0" title="0">width = int(w)</span>
                        }
                        <span class="cov0" title="0">fmt.Println(strings.Repeat("-", width))
                        return nil</span>
                }),
        }

        <span class="cov8" title="1">RegisterModule(env, "print", functions)</span>
}</pre>
		
		<pre class="file" id="file16" style="display: none">package r2libs

import (
        "math/rand"
        "time"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"
)

var localRand *rand.Rand = rand.New(rand.NewSource(time.Now().UnixNano()))

func RegisterRand(env *r2core.Environment) <span class="cov8" title="1">{
        functions := map[string]r2core.BuiltinFunction{
                "randInit": r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                        if len(args) == 0 </span><span class="cov0" title="0">{
                                localRand = rand.New(rand.NewSource(time.Now().UnixNano()))
                        }</span> else<span class="cov0" title="0"> {
                                seed := toFloat(args[0])
                                localRand = rand.New(rand.NewSource(int64(seed)))
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }),

                "randInt": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("randInt needs (min, max)")</span>
                        }
                        <span class="cov0" title="0">min := int(toFloat(args[0]))
                        max := int(toFloat(args[1]))
                        if max &lt; min </span><span class="cov0" title="0">{
                                panic("randInt: max &lt; min")</span>
                        }
                        <span class="cov0" title="0">return float64(localRand.Intn(max-min+1) + min)</span>
                }),

                "randFloat": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        return localRand.Float64()
                }</span>),

                "randChoice": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("randChoice needs (array)")</span>
                        }
                        <span class="cov0" title="0">arr, ok := args[0].([]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                panic("randChoice: first arg should be native []array")</span>
                        }
                        <span class="cov0" title="0">if len(arr) == 0 </span><span class="cov0" title="0">{
                                panic("randChoice: array empty. No elements to choose from")</span>
                        }
                        <span class="cov0" title="0">idx := localRand.Intn(len(arr))
                        return arr[idx]</span>
                }),

                "shuffle": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("shuffle needs (array)")</span>
                        }
                        <span class="cov0" title="0">arr, ok := args[0].([]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                panic("shuffle: first arg should be native []array")</span>
                        }
                        <span class="cov0" title="0">n := len(arr)
                        for i := n - 1; i &gt; 0; i-- </span><span class="cov0" title="0">{
                                j := localRand.Intn(i + 1)
                                arr[i], arr[j] = arr[j], arr[i]
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }),

                "sample": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("sample needs (array, n)")</span>
                        }
                        <span class="cov0" title="0">arr, ok := args[0].([]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                panic("sample: first arg should be native []array")</span>
                        }
                        <span class="cov0" title="0">n := int(toFloat(args[1]))
                        if n &lt; 0 </span><span class="cov0" title="0">{
                                panic("sample: n &lt; 0")</span>
                        }
                        <span class="cov0" title="0">if n &gt; len(arr) </span><span class="cov0" title="0">{
                                panic("sample: n &gt; length of array")</span>
                        }
                        <span class="cov0" title="0">cloned := make([]interface{}, len(arr))
                        copy(cloned, arr)
                        for i := len(cloned) - 1; i &gt; 0; i-- </span><span class="cov0" title="0">{
                                j := localRand.Intn(i + 1)
                                cloned[i], cloned[j] = cloned[j], cloned[i]
                        }</span>
                        <span class="cov0" title="0">return cloned[:n]</span>
                }),
        }
        
        <span class="cov8" title="1">RegisterModule(env, "rand", functions)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package r2libs

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "mime/multipart"
        "net/http"
        "net/http/cookiejar"
        "net/url"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"
)

var (
        globalCookieJar     *cookiejar.Jar
        globalCookieJarOnce sync.Once
)

func initGlobalCookieJar() <span class="cov8" title="1">{
        globalCookieJarOnce.Do(func() </span><span class="cov8" title="1">{
                jar, _ := cookiejar.New(nil)
                globalCookieJar = jar
        }</span>)
}

// r2requests.go: Python requests-like HTTP client library for R2Lang

// Response represents an HTTP response with Python requests-like interface
type Response struct {
        URL        string
        StatusCode int
        Headers    map[string]interface{}
        Text       string
        JSON       interface{}
        Content    []byte
        OK         bool
        Elapsed    time.Duration
}

// Session represents an HTTP session for reusing connections and settings
type Session struct {
        Client     *http.Client
        Headers    map[string]string
        Auth       *BasicAuth
        Timeout    time.Duration
        Verify     bool
        BaseURL    string
        Proxies    map[string]string
        MaxRetries int
        RetryDelay time.Duration
}

// BasicAuth represents HTTP Basic Authentication
type BasicAuth struct {
        Username string
        Password string
}

func RegisterRequests(env *r2core.Environment) <span class="cov8" title="1">{
        initGlobalCookieJar()
        
        functions := map[string]r2core.BuiltinFunction{
                "get":       r2core.BuiltinFunction(globalGet),
                "post":      r2core.BuiltinFunction(globalPost),
                "put":       r2core.BuiltinFunction(globalPut),
                "delete":    r2core.BuiltinFunction(globalDelete),
                "patch":     r2core.BuiltinFunction(globalPatch),
                "head":      r2core.BuiltinFunction(globalHead),
                "options":   r2core.BuiltinFunction(globalOptions),
                "session":   r2core.BuiltinFunction(createSession),
                "urlencode": r2core.BuiltinFunction(urlEncode),
                "urldecode": r2core.BuiltinFunction(urlDecode),
        }

        RegisterModule(env, "request", functions)
}</span>

// Global request functions that create a new session for each request
func globalGet(args ...interface{}) interface{} <span class="cov8" title="1">{
        return makeRequest("GET", args...)
}</span>

func globalPost(args ...interface{}) interface{} <span class="cov8" title="1">{
        return makeRequest("POST", args...)
}</span>

func globalPut(args ...interface{}) interface{} <span class="cov8" title="1">{
        return makeRequest("PUT", args...)
}</span>

func globalDelete(args ...interface{}) interface{} <span class="cov8" title="1">{
        return makeRequest("DELETE", args...)
}</span>

func globalPatch(args ...interface{}) interface{} <span class="cov0" title="0">{
        return makeRequest("PATCH", args...)
}</span>

func globalHead(args ...interface{}) interface{} <span class="cov8" title="1">{
        return makeRequest("HEAD", args...)
}</span>

func globalOptions(args ...interface{}) interface{} <span class="cov8" title="1">{
        return makeRequest("OPTIONS", args...)
}</span>

// makeRequest creates a temporary session and makes a request
func makeRequest(method string, args ...interface{}) interface{} <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("%s requires at least a URL", method))</span>
        }

        <span class="cov8" title="1">url, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("%s: URL must be a string", method))</span>
        }

        // Create temporary session
        <span class="cov8" title="1">session := &amp;Session{
                Client:     &amp;http.Client{Jar: globalCookieJar, Timeout: 30 * time.Second},
                Headers:    make(map[string]string),
                Timeout:    30 * time.Second,
                Verify:     true,
                Proxies:    make(map[string]string),
                MaxRetries: 0,
                RetryDelay: time.Second,
        }

        // Parse optional parameters
        var params map[string]interface{}
        if len(args) &gt; 1 </span><span class="cov8" title="1">{
                if p, ok := args[1].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        params = p
                }</span>
        }

        <span class="cov8" title="1">return session.request(method, url, params)</span>
}

// createSession creates a new Session object
func createSession(args ...interface{}) interface{} <span class="cov8" title="1">{
        jar, _ := cookiejar.New(nil)
        session := &amp;Session{
                Client:     &amp;http.Client{Jar: jar, Timeout: 30 * time.Second},
                Headers:    make(map[string]string),
                Timeout:    30 * time.Second,
                Verify:     true,
                Proxies:    make(map[string]string),
                MaxRetries: 0,
                RetryDelay: time.Second,
        }

        // Return session as a map with methods
        sessionMap := make(map[string]interface{})
        sessionMap["get"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                return session.sessionGet(args...)
        }</span>)
        <span class="cov8" title="1">sessionMap["post"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                return session.sessionPost(args...)
        }</span>)
        <span class="cov8" title="1">sessionMap["put"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                return session.sessionPut(args...)
        }</span>)
        <span class="cov8" title="1">sessionMap["delete"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                return session.sessionDelete(args...)
        }</span>)
        <span class="cov8" title="1">sessionMap["patch"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                return session.sessionPatch(args...)
        }</span>)
        <span class="cov8" title="1">sessionMap["head"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                return session.sessionHead(args...)
        }</span>)
        <span class="cov8" title="1">sessionMap["options"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                return session.sessionOptions(args...)
        }</span>)
        <span class="cov8" title="1">sessionMap["close"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                session.Client.CloseIdleConnections()
                return nil
        }</span>)

        <span class="cov8" title="1">return sessionMap</span>
}

// Session methods
func (s *Session) sessionGet(args ...interface{}) interface{} <span class="cov8" title="1">{
        return s.sessionRequest("GET", args...)
}</span>

func (s *Session) sessionPost(args ...interface{}) interface{} <span class="cov8" title="1">{
        return s.sessionRequest("POST", args...)
}</span>

func (s *Session) sessionPut(args ...interface{}) interface{} <span class="cov0" title="0">{
        return s.sessionRequest("PUT", args...)
}</span>

func (s *Session) sessionDelete(args ...interface{}) interface{} <span class="cov0" title="0">{
        return s.sessionRequest("DELETE", args...)
}</span>

func (s *Session) sessionPatch(args ...interface{}) interface{} <span class="cov0" title="0">{
        return s.sessionRequest("PATCH", args...)
}</span>

func (s *Session) sessionHead(args ...interface{}) interface{} <span class="cov0" title="0">{
        return s.sessionRequest("HEAD", args...)
}</span>

func (s *Session) sessionOptions(args ...interface{}) interface{} <span class="cov0" title="0">{
        return s.sessionRequest("OPTIONS", args...)
}</span>

func (s *Session) sessionRequest(method string, args ...interface{}) interface{} <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("%s requires at least a URL", method))</span>
        }

        <span class="cov8" title="1">url, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("%s: URL must be a string", method))</span>
        }

        // Parse optional parameters
        <span class="cov8" title="1">var params map[string]interface{}
        if len(args) &gt; 1 </span><span class="cov0" title="0">{
                if p, ok := args[1].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        params = p
                }</span>
        }

        <span class="cov8" title="1">return s.request(method, url, params)</span>
}

// request performs the actual HTTP request
func (s *Session) request(method, reqURL string, params map[string]interface{}) interface{} <span class="cov8" title="1">{
        start := time.Now()

        // Handle base URL
        if s.BaseURL != "" &amp;&amp; !strings.HasPrefix(reqURL, "http") </span><span class="cov0" title="0">{
                reqURL = strings.TrimSuffix(s.BaseURL, "/") + "/" + strings.TrimPrefix(reqURL, "/")
        }</span>

        // Prepare request body data. We need to be able to re-read this for retries.
        <span class="cov8" title="1">var bodyBytes []byte
        var contentType string

        if params != nil </span><span class="cov8" title="1">{
                if files, exists := params["files"]; exists </span><span class="cov8" title="1">{
                        if filesMap, ok := files.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                var b bytes.Buffer
                                writer := multipart.NewWriter(&amp;b)
                                for key, value := range filesMap </span><span class="cov8" title="1">{
                                        if filePath, ok := value.(string); ok </span><span class="cov8" title="1">{
                                                file, err := os.Open(filePath)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        panic(fmt.Sprintf("Failed to open file: %v", err))</span>
                                                }
                                                <span class="cov8" title="1">defer file.Close()
                                                part, err := writer.CreateFormFile(key, filepath.Base(filePath))
                                                if err != nil </span><span class="cov0" title="0">{
                                                        panic(fmt.Sprintf("Failed to create form file: %v", err))</span>
                                                }
                                                <span class="cov8" title="1">_, err = io.Copy(part, file)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        panic(fmt.Sprintf("Failed to copy file content: %v", err))</span>
                                                }
                                        }
                                }
                                <span class="cov8" title="1">if data, exists := params["data"]; exists </span><span class="cov8" title="1">{
                                        if dataMap, ok := data.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                                for key, value := range dataMap </span><span class="cov8" title="1">{
                                                        _ = writer.WriteField(key, fmt.Sprint(value))
                                                }</span>
                                        }
                                }
                                <span class="cov8" title="1">writer.Close()
                                bodyBytes = b.Bytes()
                                contentType = writer.FormDataContentType()</span>
                        }
                } else<span class="cov8" title="1"> {
                        contentType = "application/json" // Default
                        if data, exists := params["data"]; exists </span><span class="cov0" title="0">{
                                switch d := data.(type) </span>{
                                case string:<span class="cov0" title="0">
                                        bodyBytes = []byte(d)
                                        contentType = "text/plain"</span>
                                default:<span class="cov0" title="0">
                                        jsonData, err := json.Marshal(d)
                                        if err != nil </span><span class="cov0" title="0">{
                                                panic(fmt.Sprintf("Failed to encode data: %v", err))</span>
                                        }
                                        <span class="cov0" title="0">bodyBytes = jsonData</span>
                                }
                        }
                        <span class="cov8" title="1">if jsonData, exists := params["json"]; exists </span><span class="cov8" title="1">{
                                data, err := json.Marshal(jsonData)
                                if err != nil </span><span class="cov0" title="0">{
                                        panic(fmt.Sprintf("Failed to encode JSON: %v", err))</span>
                                }
                                <span class="cov8" title="1">bodyBytes = data
                                contentType = "application/json"</span>
                        }
                }

                <span class="cov8" title="1">if urlParams, exists := params["params"]; exists </span><span class="cov8" title="1">{
                        if paramMap, ok := urlParams.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                values := url.Values{}
                                for k, v := range paramMap </span><span class="cov8" title="1">{
                                        values.Add(k, fmt.Sprint(v))
                                }</span>
                                <span class="cov8" title="1">if strings.Contains(reqURL, "?") </span><span class="cov0" title="0">{
                                        reqURL += "&amp;" + values.Encode()
                                }</span> else<span class="cov8" title="1"> {
                                        reqURL += "?" + values.Encode()
                                }</span>
                        }
                }
                <span class="cov8" title="1">if proxies, exists := params["proxies"]; exists </span><span class="cov8" title="1">{
                        if proxiesMap, ok := proxies.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                proxyURL, err := getProxy(proxiesMap)
                                if err != nil </span><span class="cov0" title="0">{
                                        panic(fmt.Sprintf("Invalid proxy configuration: %v", err))</span>
                                }
                                <span class="cov8" title="1">if proxyURL != nil </span><span class="cov8" title="1">{
                                        s.Client.Transport = &amp;http.Transport{Proxy: http.ProxyURL(proxyURL)}
                                }</span>
                        }
                }
                <span class="cov8" title="1">if retries, exists := params["retries"]; exists </span><span class="cov8" title="1">{
                        if retriesMap, ok := retries.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                if max, ok := retriesMap["max"].(float64); ok </span><span class="cov8" title="1">{
                                        s.MaxRetries = int(max)
                                }</span>
                                <span class="cov8" title="1">if delay, ok := retriesMap["delay"].(float64); ok </span><span class="cov8" title="1">{
                                        s.RetryDelay = time.Duration(delay) * time.Second
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">var resp *http.Response
        var err error

        for i := 0; i &lt;= s.MaxRetries; i++ </span><span class="cov8" title="1">{
                ctx := context.Background()
                if s.Timeout &gt; 0 </span><span class="cov8" title="1">{
                        var cancel context.CancelFunc
                        ctx, cancel = context.WithTimeout(ctx, s.Timeout)
                        defer cancel()
                }</span>
                <span class="cov8" title="1">if params != nil </span><span class="cov8" title="1">{
                        if timeout, exists := params["timeout"]; exists </span><span class="cov8" title="1">{
                                if timeoutVal, ok := timeout.(float64); ok </span><span class="cov8" title="1">{
                                        duration := time.Duration(timeoutVal) * time.Second
                                        var cancel context.CancelFunc
                                        ctx, cancel = context.WithTimeout(ctx, duration)
                                        defer cancel()
                                }</span>
                        }
                }

                <span class="cov8" title="1">var bodyReader io.Reader
                if bodyBytes != nil </span><span class="cov8" title="1">{
                        bodyReader = bytes.NewReader(bodyBytes)
                }</span>

                <span class="cov8" title="1">req, reqErr := http.NewRequestWithContext(ctx, method, reqURL, bodyReader)
                if reqErr != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("Failed to create request: %v", reqErr))</span>
                }

                <span class="cov8" title="1">if contentType != "" </span><span class="cov8" title="1">{
                        req.Header.Set("Content-Type", contentType)
                }</span>
                <span class="cov8" title="1">for k, v := range s.Headers </span><span class="cov0" title="0">{
                        req.Header.Set(k, v)
                }</span>
                <span class="cov8" title="1">if params != nil </span><span class="cov8" title="1">{
                        if headers, exists := params["headers"]; exists </span><span class="cov8" title="1">{
                                if headerMap, ok := headers.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                        for k, v := range headerMap </span><span class="cov8" title="1">{
                                                req.Header.Set(k, fmt.Sprint(v))
                                        }</span>
                                }
                        }
                }

                <span class="cov8" title="1">if s.Auth != nil </span><span class="cov0" title="0">{
                        req.SetBasicAuth(s.Auth.Username, s.Auth.Password)
                }</span>
                <span class="cov8" title="1">if params != nil </span><span class="cov8" title="1">{
                        if auth, exists := params["auth"]; exists </span><span class="cov8" title="1">{
                                if authArray, ok := auth.([]interface{}); ok &amp;&amp; len(authArray) == 2 </span><span class="cov8" title="1">{
                                        username := fmt.Sprint(authArray[0])
                                        password := fmt.Sprint(authArray[1])
                                        req.SetBasicAuth(username, password)
                                }</span>
                        }
                }

                <span class="cov8" title="1">resp, err = s.Client.Do(req)
                if err == nil &amp;&amp; resp.StatusCode &lt; 500 </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if resp != nil </span><span class="cov8" title="1">{
                        resp.Body.Close()
                }</span>

                <span class="cov8" title="1">if i &lt; s.MaxRetries </span><span class="cov8" title="1">{
                        time.Sleep(s.RetryDelay)
                }</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("Request failed after %d retries: %v", s.MaxRetries, err))</span>
        }
        <span class="cov8" title="1">defer resp.Body.Close()

        respBody, readErr := io.ReadAll(resp.Body)
        if readErr != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Failed to read response body: %v", readErr))</span>
        }

        <span class="cov8" title="1">headers := make(map[string]interface{})
        for name, values := range resp.Header </span><span class="cov8" title="1">{
                if len(values) == 1 </span><span class="cov8" title="1">{
                        headers[name] = values[0]
                }</span> else<span class="cov0" title="0"> {
                        headers[name] = values
                }</span>
        }

        <span class="cov8" title="1">var jsonResponse interface{}
        if len(respBody) &gt; 0 </span><span class="cov8" title="1">{
                contentType := resp.Header.Get("Content-Type")
                if strings.Contains(contentType, "application/json") </span><span class="cov8" title="1">{
                        json.Unmarshal(respBody, &amp;jsonResponse)
                }</span>
        }

        <span class="cov8" title="1">response := &amp;Response{
                URL:        resp.Request.URL.String(),
                StatusCode: resp.StatusCode,
                Headers:    headers,
                Text:       string(respBody),
                JSON:       jsonResponse,
                Content:    respBody,
                OK:         resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 300,
                Elapsed:    time.Since(start),
        }

        return responseToMap(response)</span>
}

// responseToMap converts Response struct to map for R2Lang
func responseToMap(resp *Response) map[string]interface{} <span class="cov8" title="1">{
        return map[string]interface{}{
                "url":         resp.URL,
                "status_code": resp.StatusCode,
                "headers":     resp.Headers,
                "text":        resp.Text,
                "json":        resp.JSON,
                "content":     resp.Content,
                "ok":          resp.OK,
                "elapsed":     resp.Elapsed.Seconds(),
                "json_func": r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                        return resp.JSON
                }</span>),
                "raise_for_status": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov8" title="1">{
                        if !resp.OK </span><span class="cov8" title="1">{
                                panic(fmt.Sprintf("HTTP %d Error: %s", resp.StatusCode, resp.Text))</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }),
        }
}

// Utility functions
func urlEncode(args ...interface{}) interface{} <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                panic("urlencode requires a string argument")</span>
        }

        <span class="cov8" title="1">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("urlencode: argument must be a string")</span>
        }

        <span class="cov8" title="1">return url.QueryEscape(str)</span>
}

func urlDecode(args ...interface{}) interface{} <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                panic("urldecode requires a string argument")</span>
        }

        <span class="cov8" title="1">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("urldecode: argument must be a string")</span>
        }

        <span class="cov8" title="1">decoded, err := url.QueryUnescape(str)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("urldecode failed: %v", err))</span>
        }

        <span class="cov8" title="1">return decoded</span>
}

func getProxy(proxiesMap map[string]interface{}) (*url.URL, error) <span class="cov8" title="1">{
        if httpProxy, ok := proxiesMap["http"]; ok </span><span class="cov8" title="1">{
                if httpProxyStr, ok := httpProxy.(string); ok </span><span class="cov8" title="1">{
                        return url.Parse(httpProxyStr)
                }</span>
        }
        <span class="cov0" title="0">if httpsProxy, ok := proxiesMap["https"]; ok </span><span class="cov0" title="0">{
                if httpsProxyStr, ok := httpsProxy.(string); ok </span><span class="cov0" title="0">{
                        return url.Parse(httpsProxyStr)
                }</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package r2libs

import (
        "crypto/tls"
        "encoding/base64"
        "encoding/xml"
        "fmt"
        "io"
        "net/http"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"
)

// r2soap.go: Dynamic SOAP client library for R2Lang with WSDL parsing

// SOAPClient represents a dynamic SOAP client
type SOAPClient struct {
        WSDLURL       string
        ServiceURL    string
        Namespace     string
        Operations    map[string]*SOAPOperation
        HTTPTimeout   time.Duration
        Headers       map[string]string
        TLSConfig     *tls.Config
        SkipTLSVerify bool
        Auth          *SOAPAuth
}

// SOAPAuth represents authentication configuration
type SOAPAuth struct {
        Type     string // "basic", "bearer", "certificate"
        Username string
        Password string
        Token    string
        CertFile string
        KeyFile  string
}

// SOAPOperation represents a SOAP operation with its parameters
type SOAPOperation struct {
        Name         string
        SOAPAction   string
        InputMessage string
        Parameters   []SOAPParameter
}

// SOAPParameter represents a parameter for a SOAP operation
type SOAPParameter struct {
        Name string
        Type string
}

// WSDLDefinitions represents the root element of a WSDL document
type WSDLDefinitions struct {
        XMLName   xml.Name       `xml:"definitions"`
        TargetNS  string         `xml:"targetNamespace,attr"`
        Services  []WSDLService  `xml:"service"`
        PortTypes []WSDLPortType `xml:"portType"`
        Bindings  []WSDLBinding  `xml:"binding"`
        Messages  []WSDLMessage  `xml:"message"`
        Types     WSDLTypes      `xml:"types"`
}

// WSDLService represents a WSDL service
type WSDLService struct {
        Name  string     `xml:"name,attr"`
        Ports []WSDLPort `xml:"port"`
}

// WSDLPort represents a WSDL port
type WSDLPort struct {
        Name    string          `xml:"name,attr"`
        Address WSDLSoapAddress `xml:"address"`
}

// WSDLSoapAddress represents a SOAP address
type WSDLSoapAddress struct {
        Location string `xml:"location,attr"`
}

// WSDLPortType represents a WSDL port type
type WSDLPortType struct {
        Name       string          `xml:"name,attr"`
        Operations []WSDLOperation `xml:"operation"`
}

// WSDLOperation represents a WSDL operation
type WSDLOperation struct {
        Name   string      `xml:"name,attr"`
        Input  WSDLMessage `xml:"input"`
        Output WSDLMessage `xml:"output"`
}

// WSDLBinding represents a WSDL binding
type WSDLBinding struct {
        Name       string                 `xml:"name,attr"`
        Type       string                 `xml:"type,attr"`
        Operations []WSDLBindingOperation `xml:"operation"`
}

// WSDLBindingOperation represents a WSDL binding operation
type WSDLBindingOperation struct {
        Name       string         `xml:"name,attr"`
        SOAPAction WSDLSoapAction `xml:"operation"`
}

// WSDLSoapAction represents a SOAP action
type WSDLSoapAction struct {
        SOAPAction string `xml:"soapAction,attr"`
}

// WSDLMessage represents a WSDL message
type WSDLMessage struct {
        Name  string     `xml:"name,attr"`
        Parts []WSDLPart `xml:"part"`
}

// WSDLPart represents a WSDL message part
type WSDLPart struct {
        Name    string `xml:"name,attr"`
        Element string `xml:"element,attr"`
        Type    string `xml:"type,attr"`
}

// WSDLTypes represents WSDL types
type WSDLTypes struct {
        Schemas []WSDLSchema `xml:"schema"`
}

// WSDLSchema represents a WSDL schema
type WSDLSchema struct {
        Elements []WSDLElement `xml:"element"`
}

// WSDLElement represents a WSDL element
type WSDLElement struct {
        Name string `xml:"name,attr"`
        Type string `xml:"type,attr"`
}

// RegisterSOAP registers SOAP functions in R2Lang environment
func RegisterSOAP(env *r2core.Environment) <span class="cov8" title="1">{
        functions := map[string]r2core.BuiltinFunction{
                "soapClient": r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("soapClient requires (wsdlURL, [customHeaders])")</span>
                        }

                        <span class="cov8" title="1">wsdlURL, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("soapClient: wsdlURL must be a string")</span>
                        }

                        // Parse optional custom headers
                        <span class="cov8" title="1">var customHeaders map[string]interface{}
                        if len(args) &gt; 1 </span><span class="cov8" title="1">{
                                if headers, ok := args[1].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                        customHeaders = headers
                                }</span> else<span class="cov0" title="0"> {
                                        panic("soapClient: customHeaders must be a map")</span>
                                }
                        }

                        <span class="cov8" title="1">client, err := createSOAPClient(wsdlURL, customHeaders)
                        if err != nil </span><span class="cov8" title="1">{
                                // Provide more detailed error information
                                errorMsg := fmt.Sprintf("soapClient: failed to create client from '%s'", wsdlURL)
                                if strings.Contains(err.Error(), "connection reset") </span><span class="cov0" title="0">{
                                        errorMsg += " - Network connectivity issue. The WSDL service may be unavailable or blocking requests."
                                }</span> else<span class="cov8" title="1"> if strings.Contains(err.Error(), "no such host") </span><span class="cov8" title="1">{
                                        errorMsg += " - DNS resolution failed. Check the URL and internet connectivity."
                                }</span> else<span class="cov8" title="1"> if strings.Contains(err.Error(), "timeout") </span><span class="cov0" title="0">{
                                        errorMsg += " - Request timeout. The service may be slow or overloaded."
                                }</span>
                                <span class="cov8" title="1">errorMsg += fmt.Sprintf(" Error: %v", err)
                                panic(errorMsg)</span>
                        }

                        <span class="cov8" title="1">return soapClientToMap(client)</span>
                }),

                "soapEnvelope": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov8" title="1">{
                        if len(args) &lt; 3 </span><span class="cov8" title="1">{
                                panic("soapEnvelope requires (namespace, methodName, bodyContent)")</span>
                        }

                        <span class="cov8" title="1">namespace, ok1 := args[0].(string)
                        methodName, ok2 := args[1].(string)
                        bodyContent, ok3 := args[2].(string)

                        if !ok1 || !ok2 || !ok3 </span><span class="cov0" title="0">{
                                panic("soapEnvelope: all parameters must be strings")</span>
                        }

                        <span class="cov8" title="1">envelope := createSOAPEnvelope(namespace, methodName, bodyContent)
                        return envelope</span>
                }),

                "soapRequest": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov8" title="1">{
                        if len(args) &lt; 3 </span><span class="cov8" title="1">{
                                panic("soapRequest requires (url, soapAction, envelope)")</span>
                        }

                        <span class="cov8" title="1">url, ok1 := args[0].(string)
                        soapAction, ok2 := args[1].(string)
                        envelope, ok3 := args[2].(string)

                        if !ok1 || !ok2 || !ok3 </span><span class="cov0" title="0">{
                                panic("soapRequest: all parameters must be strings")</span>
                        }

                        <span class="cov8" title="1">response, err := sendSOAPRequest(url, soapAction, envelope)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("soapRequest: %v", err))</span>
                        }

                        <span class="cov8" title="1">return response</span>
                }),
        }

        <span class="cov8" title="1">RegisterModule(env, "soap", functions)</span>
}

// createSOAPClient creates a new SOAP client from WSDL URL with optional custom headers
func createSOAPClient(wsdlURL string, customHeaders map[string]interface{}) (*SOAPClient, error) <span class="cov8" title="1">{
        // Create HTTP client with TLS configuration
        transport := &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{
                        InsecureSkipVerify: false, // Default to secure
                        MinVersion:         tls.VersionTLS12,
                },
        }
        httpClient := &amp;http.Client{
                Timeout:   30 * time.Second,
                Transport: transport,
        }

        req, err := http.NewRequest("GET", wsdlURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %v", err)
        }</span>

        // Set browser-like headers to avoid blocking
        <span class="cov8" title="1">req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
        req.Header.Set("Accept", "text/xml,application/xml,*/*")
        req.Header.Set("Accept-Language", "en-US,en;q=0.9")

        // Fetch WSDL document
        resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to fetch WSDL: %v", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        wsdlData, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read WSDL: %v", err)
        }</span>

        // Parse WSDL
        <span class="cov8" title="1">var wsdl WSDLDefinitions
        err = xml.Unmarshal(wsdlData, &amp;wsdl)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse WSDL: %v", err)
        }</span>

        // Extract service URL
        <span class="cov8" title="1">serviceURL := ""
        if len(wsdl.Services) &gt; 0 &amp;&amp; len(wsdl.Services[0].Ports) &gt; 0 </span><span class="cov8" title="1">{
                serviceURL = wsdl.Services[0].Ports[0].Address.Location
        }</span>

        // Extract operations
        <span class="cov8" title="1">operations := make(map[string]*SOAPOperation)

        // Build operation map from portTypes and bindings
        for _, portType := range wsdl.PortTypes </span><span class="cov8" title="1">{
                for _, op := range portType.Operations </span><span class="cov8" title="1">{
                        operation := &amp;SOAPOperation{
                                Name:         op.Name,
                                InputMessage: op.Input.Name,
                                Parameters:   []SOAPParameter{},
                        }

                        // Find corresponding binding for SOAPAction
                        for _, binding := range wsdl.Bindings </span><span class="cov8" title="1">{
                                for _, bindingOp := range binding.Operations </span><span class="cov8" title="1">{
                                        if bindingOp.Name == op.Name </span><span class="cov8" title="1">{
                                                operation.SOAPAction = bindingOp.SOAPAction.SOAPAction
                                                break</span>
                                        }
                                }
                        }

                        <span class="cov8" title="1">operations[op.Name] = operation</span>
                }
        }

        // Initialize client with browser-like defaults
        <span class="cov8" title="1">defaultHeaders := map[string]string{
                "User-Agent":      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                "Accept":          "text/xml,application/xml,*/*",
                "Accept-Language": "en-US,en;q=0.9",
                "Accept-Encoding": "gzip, deflate",
                "Connection":      "keep-alive",
        }

        // Override with custom headers if provided
        if customHeaders != nil </span><span class="cov8" title="1">{
                for key, value := range customHeaders </span><span class="cov8" title="1">{
                        if strValue, ok := value.(string); ok </span><span class="cov8" title="1">{
                                defaultHeaders[key] = strValue
                        }</span>
                }
        }

        <span class="cov8" title="1">client := &amp;SOAPClient{
                WSDLURL:       wsdlURL,
                ServiceURL:    serviceURL,
                Namespace:     wsdl.TargetNS,
                Operations:    operations,
                HTTPTimeout:   30 * time.Second,
                Headers:       defaultHeaders,
                TLSConfig:     &amp;tls.Config{},
                SkipTLSVerify: false,
                Auth:          nil,
        }

        return client, nil</span>
}

// soapClientToMap converts SOAPClient to R2Lang map with methods
func soapClientToMap(client *SOAPClient) map[string]interface{} <span class="cov8" title="1">{
        clientMap := make(map[string]interface{})

        // Client properties
        clientMap["wsdlURL"] = client.WSDLURL
        clientMap["serviceURL"] = client.ServiceURL
        clientMap["namespace"] = client.Namespace

        // List available operations
        clientMap["listOperations"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                operations := make([]interface{}, 0, len(client.Operations))
                for name := range client.Operations </span><span class="cov8" title="1">{
                        operations = append(operations, name)
                }</span>
                <span class="cov8" title="1">return operations</span>
        })

        // Get operation info
        <span class="cov8" title="1">clientMap["getOperation"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        panic("getOperation requires (operationName)")</span>
                }

                <span class="cov8" title="1">operationName, ok := args[0].(string)
                if !ok </span><span class="cov0" title="0">{
                        panic("getOperation: operationName must be a string")</span>
                }

                <span class="cov8" title="1">operation, exists := client.Operations[operationName]
                if !exists </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("getOperation: operation '%s' not found", operationName))</span>
                }

                <span class="cov8" title="1">return map[string]interface{}{
                        "name":       operation.Name,
                        "soapAction": operation.SOAPAction,
                        "message":    operation.InputMessage,
                }</span>
        })

        // Call SOAP operation dynamically with response parsing
        <span class="cov8" title="1">clientMap["call"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        panic("call requires (operationName, parameters)")</span>
                }

                <span class="cov8" title="1">operationName, ok1 := args[0].(string)
                params, ok2 := args[1].(map[string]interface{})

                if !ok1 </span><span class="cov0" title="0">{
                        panic("call: operationName must be a string")</span>
                }
                <span class="cov8" title="1">if !ok2 </span><span class="cov0" title="0">{
                        panic("call: parameters must be a map")</span>
                }

                <span class="cov8" title="1">return client.callOperation(operationName, params)</span>
        })

        // Call SOAP operation and return only the result value (simplified)
        <span class="cov8" title="1">clientMap["callSimple"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        panic("callSimple requires (operationName, parameters)")</span>
                }

                <span class="cov8" title="1">operationName, ok1 := args[0].(string)
                params, ok2 := args[1].(map[string]interface{})

                if !ok1 </span><span class="cov0" title="0">{
                        panic("callSimple: operationName must be a string")</span>
                }
                <span class="cov8" title="1">if !ok2 </span><span class="cov0" title="0">{
                        panic("callSimple: parameters must be a map")</span>
                }

                <span class="cov8" title="1">response := client.callOperation(operationName, params)
                if responseMap, ok := response.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        // Check if the call was successful
                        if success, exists := responseMap["success"]; exists &amp;&amp; success == true </span><span class="cov8" title="1">{
                                // Return just the result value if available
                                if result, exists := responseMap["result"]; exists &amp;&amp; result != nil </span><span class="cov8" title="1">{
                                        return result
                                }</span>
                                // Fall back to first value in values map
                                <span class="cov0" title="0">if values, exists := responseMap["values"]; exists </span><span class="cov0" title="0">{
                                        if valuesMap, ok := values.(map[string]interface{}); ok &amp;&amp; len(valuesMap) &gt; 0 </span><span class="cov0" title="0">{
                                                // Return the first non-empty value
                                                for _, value := range valuesMap </span><span class="cov0" title="0">{
                                                        if value != nil &amp;&amp; value != "" </span><span class="cov0" title="0">{
                                                                return value
                                                        }</span>
                                                }
                                                <span class="cov0" title="0">return valuesMap</span>
                                        }
                                }
                        } else<span class="cov0" title="0"> {
                                // If call failed, return error info
                                if fault, exists := responseMap["fault"]; exists </span><span class="cov0" title="0">{
                                        return fault
                                }</span>
                                <span class="cov0" title="0">if err, exists := responseMap["error"]; exists </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
                <span class="cov0" title="0">return response</span>
        })

        // Get response in raw XML format
        <span class="cov8" title="1">clientMap["callRaw"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        panic("callRaw requires (operationName, parameters)")</span>
                }

                <span class="cov8" title="1">operationName, ok1 := args[0].(string)
                params, ok2 := args[1].(map[string]interface{})

                if !ok1 </span><span class="cov0" title="0">{
                        panic("callRaw: operationName must be a string")</span>
                }
                <span class="cov8" title="1">if !ok2 </span><span class="cov0" title="0">{
                        panic("callRaw: parameters must be a map")</span>
                }

                // Call operation and extract raw response
                <span class="cov8" title="1">operation, exists := client.Operations[operationName]
                if !exists </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("operation '%s' not found", operationName))</span>
                }

                <span class="cov8" title="1">var bodyParts []string
                for key, value := range params </span><span class="cov8" title="1">{
                        bodyParts = append(bodyParts, fmt.Sprintf("&lt;%s&gt;%v&lt;/%s&gt;", key, value, key))
                }</span>
                <span class="cov8" title="1">bodyContent := strings.Join(bodyParts, "")
                envelope := createOperationSOAPEnvelope(client.Namespace, operationName, bodyContent)

                response, err := client.sendRequest(operation.SOAPAction, envelope)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("SOAP call failed: %v", err))</span>
                }

                <span class="cov8" title="1">return response</span>
        })

        // Set HTTP timeout
        <span class="cov8" title="1">clientMap["setTimeout"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        panic("setTimeout requires (seconds)")</span>
                }

                <span class="cov8" title="1">seconds, ok := args[0].(float64)
                if !ok </span><span class="cov0" title="0">{
                        panic("setTimeout: seconds must be a number")</span>
                }

                <span class="cov8" title="1">client.HTTPTimeout = time.Duration(seconds) * time.Second
                return nil</span>
        })

        // Set custom headers (single or multiple)
        <span class="cov8" title="1">clientMap["setHeader"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        panic("setHeader requires (name, value) or (headersMap)")</span>
                }

                // If single argument, treat as headers map
                <span class="cov8" title="1">if len(args) == 1 </span><span class="cov8" title="1">{
                        if headersMap, ok := args[0].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                for name, value := range headersMap </span><span class="cov8" title="1">{
                                        if strValue, ok := value.(string); ok </span><span class="cov8" title="1">{
                                                client.Headers[name] = strValue
                                        }</span>
                                }
                                <span class="cov8" title="1">return nil</span>
                        }
                }

                // If two arguments, treat as name-value pair
                <span class="cov8" title="1">if len(args) &gt;= 2 </span><span class="cov8" title="1">{
                        name, ok1 := args[0].(string)
                        value, ok2 := args[1].(string)

                        if !ok1 || !ok2 </span><span class="cov0" title="0">{
                                panic("setHeader: name and value must be strings")</span>
                        }

                        <span class="cov8" title="1">client.Headers[name] = value
                        return nil</span>
                }

                <span class="cov0" title="0">panic("setHeader: invalid arguments")</span>
        })

        // Get current headers
        <span class="cov8" title="1">clientMap["getHeaders"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                headersMap := make(map[string]interface{})
                for name, value := range client.Headers </span><span class="cov8" title="1">{
                        headersMap[name] = value
                }</span>
                <span class="cov8" title="1">return headersMap</span>
        })

        // Reset headers to browser-like defaults
        <span class="cov8" title="1">clientMap["resetHeaders"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                client.Headers = map[string]string{
                        "User-Agent":      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                        "Accept":          "text/xml,application/xml,*/*",
                        "Accept-Language": "en-US,en;q=0.9",
                        "Accept-Encoding": "gzip, deflate",
                        "Connection":      "keep-alive",
                }
                return nil
        }</span>)

        // Remove specific header
        <span class="cov8" title="1">clientMap["removeHeader"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        panic("removeHeader requires (headerName)")</span>
                }

                <span class="cov8" title="1">headerName, ok := args[0].(string)
                if !ok </span><span class="cov0" title="0">{
                        panic("removeHeader: headerName must be a string")</span>
                }

                <span class="cov8" title="1">delete(client.Headers, headerName)
                return nil</span>
        })

        // Configure SSL/TLS settings
        <span class="cov8" title="1">clientMap["setTLSConfig"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        panic("setTLSConfig requires (configMap)")</span>
                }

                <span class="cov8" title="1">configMap, ok := args[0].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        panic("setTLSConfig: configMap must be a map")</span>
                }

                // Skip certificate verification
                <span class="cov8" title="1">if skipVerify, exists := configMap["skipVerify"]; exists </span><span class="cov8" title="1">{
                        if skip, ok := skipVerify.(bool); ok </span><span class="cov8" title="1">{
                                client.SkipTLSVerify = skip
                                client.TLSConfig.InsecureSkipVerify = skip
                        }</span>
                }

                // Set minimum TLS version
                <span class="cov8" title="1">if minVersion, exists := configMap["minVersion"]; exists </span><span class="cov8" title="1">{
                        if version, ok := minVersion.(string); ok </span><span class="cov8" title="1">{
                                switch version </span>{
                                case "1.0":<span class="cov0" title="0">
                                        client.TLSConfig.MinVersion = tls.VersionTLS10</span>
                                case "1.1":<span class="cov0" title="0">
                                        client.TLSConfig.MinVersion = tls.VersionTLS11</span>
                                case "1.2":<span class="cov8" title="1">
                                        client.TLSConfig.MinVersion = tls.VersionTLS12</span>
                                case "1.3":<span class="cov8" title="1">
                                        client.TLSConfig.MinVersion = tls.VersionTLS13</span>
                                default:<span class="cov0" title="0">
                                        client.TLSConfig.MinVersion = tls.VersionTLS12</span> // Default to 1.2
                                }
                        }
                }

                <span class="cov8" title="1">return nil</span>
        })

        // Set authentication credentials
        <span class="cov8" title="1">clientMap["setAuth"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        panic("setAuth requires (authConfig)")</span>
                }

                <span class="cov8" title="1">authConfig, ok := args[0].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        panic("setAuth: authConfig must be a map")</span>
                }

                <span class="cov8" title="1">auth := &amp;SOAPAuth{}

                if authType, exists := authConfig["type"]; exists </span><span class="cov8" title="1">{
                        if typeStr, ok := authType.(string); ok </span><span class="cov8" title="1">{
                                auth.Type = typeStr
                        }</span>
                }

                <span class="cov8" title="1">if username, exists := authConfig["username"]; exists </span><span class="cov8" title="1">{
                        if userStr, ok := username.(string); ok </span><span class="cov8" title="1">{
                                auth.Username = userStr
                        }</span>
                }

                <span class="cov8" title="1">if password, exists := authConfig["password"]; exists </span><span class="cov8" title="1">{
                        if passStr, ok := password.(string); ok </span><span class="cov8" title="1">{
                                auth.Password = passStr
                        }</span>
                }

                <span class="cov8" title="1">if token, exists := authConfig["token"]; exists </span><span class="cov8" title="1">{
                        if tokenStr, ok := token.(string); ok </span><span class="cov8" title="1">{
                                auth.Token = tokenStr
                        }</span>
                }

                <span class="cov8" title="1">client.Auth = auth
                return nil</span>
        })

        // Add custom CA certificate
        <span class="cov8" title="1">clientMap["addCACert"] = r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                if len(args) &lt; 1 </span><span class="cov0" title="0">{
                        panic("addCACert requires (certPath)")</span>
                }

                <span class="cov0" title="0">certPath, ok := args[0].(string)
                if !ok </span><span class="cov0" title="0">{
                        panic("addCACert: certPath must be a string")</span>
                }

                // This would require reading cert file - placeholder for now
                // In a full implementation, you'd read the cert file and add to TLSConfig.RootCAs
                <span class="cov0" title="0">client.Headers["X-Custom-CA"] = certPath
                return nil</span>
        })

        <span class="cov8" title="1">return clientMap</span>
}

// callOperation calls a SOAP operation with given parameters
func (client *SOAPClient) callOperation(operationName string, params map[string]interface{}) interface{} <span class="cov8" title="1">{
        operation, exists := client.Operations[operationName]
        if !exists </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("operation '%s' not found", operationName))</span>
        }

        // Build SOAP body from parameters with proper namespace
        <span class="cov8" title="1">var bodyParts []string
        for key, value := range params </span><span class="cov8" title="1">{
                bodyParts = append(bodyParts, fmt.Sprintf("&lt;%s&gt;%v&lt;/%s&gt;", key, value, key))
        }</span>
        <span class="cov8" title="1">bodyContent := strings.Join(bodyParts, "")

        // Create SOAP envelope with operation-specific structure
        envelope := createOperationSOAPEnvelope(client.Namespace, operationName, bodyContent)

        // Send SOAP request
        response, err := client.sendRequest(operation.SOAPAction, envelope)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("SOAP call failed: %v", err))</span>
        }

        // Parse response to R2Lang native types
        <span class="cov8" title="1">parsedResponse := parseSOAPResponseToR2Lang(response)
        return parsedResponse</span>
}

// createOperationSOAPEnvelope creates a SOAP envelope specifically for operation calls
func createOperationSOAPEnvelope(namespace, operationName, bodyContent string) string <span class="cov8" title="1">{
        envelope := fmt.Sprintf(`&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt;
        &lt;soap:Body&gt;
                &lt;%s xmlns="%s"&gt;
                        %s
                &lt;/%s&gt;
        &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;`, operationName, namespace, bodyContent, operationName)

        return envelope
}</span>

// sendRequest sends a SOAP request with the client's configuration
func (client *SOAPClient) sendRequest(soapAction, envelope string) (string, error) <span class="cov8" title="1">{
        // Create HTTP client with TLS configuration
        transport := &amp;http.Transport{
                TLSClientConfig: client.TLSConfig,
        }
        httpClient := &amp;http.Client{
                Timeout:   client.HTTPTimeout,
                Transport: transport,
        }

        req, err := http.NewRequest("POST", client.ServiceURL, strings.NewReader(envelope))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Set SOAP headers
        <span class="cov8" title="1">req.Header.Set("Content-Type", "text/xml; charset=utf-8")
        req.Header.Set("SOAPAction", fmt.Sprintf(`"%s"`, soapAction))

        // Apply authentication if configured
        if client.Auth != nil </span><span class="cov0" title="0">{
                switch client.Auth.Type </span>{
                case "basic":<span class="cov0" title="0">
                        if client.Auth.Username != "" &amp;&amp; client.Auth.Password != "" </span><span class="cov0" title="0">{
                                credentials := base64.StdEncoding.EncodeToString([]byte(client.Auth.Username + ":" + client.Auth.Password))
                                req.Header.Set("Authorization", "Basic "+credentials)
                        }</span>
                case "bearer":<span class="cov0" title="0">
                        if client.Auth.Token != "" </span><span class="cov0" title="0">{
                                req.Header.Set("Authorization", "Bearer "+client.Auth.Token)
                        }</span>
                }
        }

        // Set custom headers (includes defaults)
        <span class="cov8" title="1">for name, value := range client.Headers </span><span class="cov8" title="1">{
                req.Header.Set(name, value)
        }</span>

        <span class="cov8" title="1">resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        responseData, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("HTTP error %d: %s", resp.StatusCode, string(responseData))
        }</span>

        <span class="cov8" title="1">return string(responseData), nil</span>
}

// createSOAPEnvelope creates a SOAP 1.1 envelope
func createSOAPEnvelope(namespace, methodName, bodyContent string) string <span class="cov8" title="1">{
        envelope := fmt.Sprintf(`&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/" xmlns:tns="%s"&gt;
        &lt;soap:Header /&gt;
        &lt;soap:Body&gt;
                &lt;tns:%s&gt;
                        %s
                &lt;/tns:%s&gt;
        &lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;`, namespace, methodName, bodyContent, methodName)

        return envelope
}</span>

// sendSOAPRequest sends a raw SOAP request
func sendSOAPRequest(url, soapAction, envelope string) (string, error) <span class="cov8" title="1">{
        client := &amp;http.Client{Timeout: 30 * time.Second}

        req, err := http.NewRequest("POST", url, strings.NewReader(envelope))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "text/xml; charset=utf-8")
        req.Header.Set("SOAPAction", fmt.Sprintf(`"%s"`, soapAction))
        req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")

        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        responseData, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("HTTP error %d: %s", resp.StatusCode, string(responseData))
        }</span>

        <span class="cov8" title="1">return string(responseData), nil</span>
}

// parseSOAPResponseToR2Lang parses SOAP response and ensures R2Lang native types
func parseSOAPResponseToR2Lang(response string) map[string]interface{} <span class="cov8" title="1">{
        // Clean the response from any binary/control characters
        cleanResponse := cleanResponseString(response)

        result := map[string]interface{}{
                "success": true,
                "raw":     cleanResponse,
        }

        // Extract SOAP body content with multiple regex patterns
        var bodyContent string
        bodyPatterns := []string{
                `(?s)&lt;soap:Body[^&gt;]*&gt;(.*?)&lt;/soap:Body&gt;`,
                `(?s)&lt;Body[^&gt;]*&gt;(.*?)&lt;/Body&gt;`,
                `(?s)&lt;.*:Body[^&gt;]*&gt;(.*?)&lt;/.*:Body&gt;`,
        }

        for _, pattern := range bodyPatterns </span><span class="cov8" title="1">{
                bodyRegex := regexp.MustCompile(pattern)
                matches := bodyRegex.FindStringSubmatch(cleanResponse)
                if len(matches) &gt;= 2 </span><span class="cov8" title="1">{
                        bodyContent = matches[1]
                        break</span>
                }
        }

        <span class="cov8" title="1">if bodyContent == "" </span><span class="cov0" title="0">{
                // If no body found, return raw response
                result["success"] = false
                result["error"] = "Could not extract SOAP body"
                return result
        }</span>

        <span class="cov8" title="1">result["body"] = bodyContent

        // Check for SOAP faults
        if strings.Contains(bodyContent, "Fault") || strings.Contains(bodyContent, "fault") </span><span class="cov0" title="0">{
                result["success"] = false
                result["fault"] = extractSOAPFaultSimple(bodyContent)
                return result
        }</span>

        // Extract values as native R2Lang types
        <span class="cov8" title="1">values := extractValuesAsR2LangTypes(bodyContent)
        result["values"] = values

        // Extract the primary result value (for callSimple)
        primaryResult := extractPrimaryResult(bodyContent)
        if primaryResult != nil </span><span class="cov8" title="1">{
                result["result"] = primaryResult
        }</span>

        <span class="cov8" title="1">return result</span>
}

// parseSOAPResponse parses a SOAP response and extracts meaningful data
func parseSOAPResponse(response string) (map[string]interface{}, error) <span class="cov8" title="1">{
        // Initialize result with success indicator
        result := map[string]interface{}{
                "success": true,
                "raw":     response,
        }

        // Extract SOAP body content
        bodyRegex := regexp.MustCompile(`&lt;soap:Body[^&gt;]*&gt;(.*?)&lt;/soap:Body&gt;`)
        if !bodyRegex.MatchString(response) </span><span class="cov8" title="1">{
                // Try alternative format without namespace
                bodyRegex = regexp.MustCompile(`&lt;Body[^&gt;]*&gt;(.*?)&lt;/Body&gt;`)
        }</span>

        // Try with multiline flag for complex XML
        <span class="cov8" title="1">if !bodyRegex.MatchString(response) </span><span class="cov8" title="1">{
                bodyRegex = regexp.MustCompile(`(?s)&lt;soap:Body[^&gt;]*&gt;(.*?)&lt;/soap:Body&gt;`)
                if !bodyRegex.MatchString(response) </span><span class="cov0" title="0">{
                        bodyRegex = regexp.MustCompile(`(?s)&lt;Body[^&gt;]*&gt;(.*?)&lt;/Body&gt;`)
                }</span>
        }

        <span class="cov8" title="1">matches := bodyRegex.FindStringSubmatch(response)
        if len(matches) &lt; 2 </span><span class="cov0" title="0">{
                return result, fmt.Errorf("could not extract SOAP body")
        }</span>

        <span class="cov8" title="1">bodyContent := matches[1]
        result["body"] = bodyContent

        // Check for SOAP faults
        if strings.Contains(bodyContent, "Fault") || strings.Contains(bodyContent, "fault") </span><span class="cov8" title="1">{
                result["success"] = false
                faultDetail := extractSOAPFault(bodyContent)
                result["fault"] = faultDetail
                return result, nil
        }</span>

        // Extract operation result values using improved parsing
        <span class="cov8" title="1">values := extractResponseValues(bodyContent)
        result["values"] = values

        // Extract numeric results (common for calculator services)
        numericResult := extractNumericResult(bodyContent)
        if numericResult != nil </span><span class="cov8" title="1">{
                result["result"] = numericResult
        }</span>

        // Provide cleaned XML for debugging
        <span class="cov8" title="1">result["cleaned"] = cleanXMLNamespaces(bodyContent)

        return result, nil</span>
}

// extractSOAPFault extracts fault information from SOAP response
func extractSOAPFault(bodyContent string) map[string]interface{} <span class="cov8" title="1">{
        fault := make(map[string]interface{})

        // Extract fault code
        codeRegex := regexp.MustCompile(`&lt;faultcode[^&gt;]*&gt;([^&lt;]+)&lt;/faultcode&gt;`)
        if matches := codeRegex.FindStringSubmatch(bodyContent); len(matches) &gt; 1 </span><span class="cov8" title="1">{
                fault["code"] = strings.TrimSpace(matches[1])
        }</span>

        // Extract fault string/message
        <span class="cov8" title="1">stringRegex := regexp.MustCompile(`&lt;faultstring[^&gt;]*&gt;([^&lt;]+)&lt;/faultstring&gt;`)
        if matches := stringRegex.FindStringSubmatch(bodyContent); len(matches) &gt; 1 </span><span class="cov8" title="1">{
                fault["message"] = strings.TrimSpace(matches[1])
        }</span>

        <span class="cov8" title="1">return fault</span>
}

// extractResponseValues extracts key-value pairs from response body
func extractResponseValues(bodyContent string) map[string]interface{} <span class="cov8" title="1">{
        values := make(map[string]interface{})

        // Extract all XML elements and their values
        elementRegex := regexp.MustCompile(`&lt;([^/&gt;\\s]+)[^&gt;]*&gt;([^&lt;]+)&lt;/[^&gt;]+&gt;`)
        matches := elementRegex.FindAllStringSubmatch(bodyContent, -1)

        for _, match := range matches </span><span class="cov8" title="1">{
                if len(match) &gt;= 3 </span><span class="cov8" title="1">{
                        key := strings.TrimSpace(match[1])
                        value := strings.TrimSpace(match[2])

                        // Try to convert to appropriate type
                        if convertedValue := tryConvertValue(value); convertedValue != nil </span><span class="cov8" title="1">{
                                values[key] = convertedValue
                        }</span> else<span class="cov0" title="0"> {
                                values[key] = value
                        }</span>
                }
        }

        <span class="cov8" title="1">return values</span>
}

// extractNumericResult extracts numeric results from common patterns
func extractNumericResult(bodyContent string) interface{} <span class="cov8" title="1">{
        // Common result patterns for calculator services
        patterns := []string{
                `&lt;[^&gt;]*Result[^&gt;]*&gt;([^&lt;]+)&lt;`,
                `&lt;result[^&gt;]*&gt;([^&lt;]+)&lt;`,
                `&lt;return[^&gt;]*&gt;([^&lt;]+)&lt;`,
                `&lt;value[^&gt;]*&gt;([^&lt;]+)&lt;`,
        }

        for _, pattern := range patterns </span><span class="cov8" title="1">{
                regex := regexp.MustCompile(pattern)
                if matches := regex.FindStringSubmatch(bodyContent); len(matches) &gt; 1 </span><span class="cov8" title="1">{
                        value := strings.TrimSpace(matches[1])
                        return tryConvertValue(value)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// extractSOAPFaultSimple extracts basic fault information
func extractSOAPFaultSimple(bodyContent string) map[string]interface{} <span class="cov0" title="0">{
        fault := map[string]interface{}{}

        // Extract fault code
        if codeRegex := regexp.MustCompile(`&lt;(?:\w+:)?faultcode[^&gt;]*&gt;([^&lt;]+)&lt;/(?:\w+:)?faultcode&gt;`); codeRegex.MatchString(bodyContent) </span><span class="cov0" title="0">{
                matches := codeRegex.FindStringSubmatch(bodyContent)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        fault["code"] = strings.TrimSpace(matches[1])
                }</span>
        }

        // Extract fault string
        <span class="cov0" title="0">if stringRegex := regexp.MustCompile(`&lt;(?:\w+:)?faultstring[^&gt;]*&gt;([^&lt;]+)&lt;/(?:\w+:)?faultstring&gt;`); stringRegex.MatchString(bodyContent) </span><span class="cov0" title="0">{
                matches := stringRegex.FindStringSubmatch(bodyContent)
                if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                        fault["message"] = strings.TrimSpace(matches[1])
                }</span>
        }

        <span class="cov0" title="0">return fault</span>
}

// extractValuesAsR2LangTypes extracts all values ensuring R2Lang native types
func extractValuesAsR2LangTypes(bodyContent string) map[string]interface{} <span class="cov8" title="1">{
        values := map[string]interface{}{}

        // Extract all XML elements and their values
        elementRegex := regexp.MustCompile(`&lt;([^/&gt;\\s]+)[^&gt;]*&gt;([^&lt;]+)&lt;/[^&gt;]+&gt;`)
        matches := elementRegex.FindAllStringSubmatch(bodyContent, -1)

        for _, match := range matches </span><span class="cov8" title="1">{
                if len(match) &gt;= 3 </span><span class="cov8" title="1">{
                        key := strings.TrimSpace(match[1])
                        value := strings.TrimSpace(match[2])

                        // Convert to R2Lang native type
                        values[key] = convertToR2LangType(value)
                }</span>
        }

        <span class="cov8" title="1">return values</span>
}

// extractPrimaryResult extracts the main result value for callSimple
func extractPrimaryResult(bodyContent string) interface{} <span class="cov8" title="1">{
        // Common result patterns for SOAP responses
        patterns := []string{
                `&lt;([^&gt;]*Result[^&gt;]*)&gt;([^&lt;]+)&lt;/[^&gt;]*Result[^&gt;]*&gt;`,
                `&lt;([^&gt;]*Response[^&gt;]*)&gt;([^&lt;]+)&lt;/[^&gt;]*Response[^&gt;]*&gt;`,
                `&lt;([^&gt;]*Return[^&gt;]*)&gt;([^&lt;]+)&lt;/[^&gt;]*Return[^&gt;]*&gt;`,
                `&lt;([^&gt;]*Value[^&gt;]*)&gt;([^&lt;]+)&lt;/[^&gt;]*Value[^&gt;]*&gt;`,
        }

        for _, pattern := range patterns </span><span class="cov8" title="1">{
                regex := regexp.MustCompile(pattern)
                if matches := regex.FindStringSubmatch(bodyContent); len(matches) &gt; 2 </span><span class="cov8" title="1">{
                        return convertToR2LangType(strings.TrimSpace(matches[2]))
                }</span>
        }

        // If no specific result pattern, try to extract any numeric value
        <span class="cov0" title="0">numericRegex := regexp.MustCompile(`&gt;(\d+(?:\.\d+)?)&lt;`)
        if matches := numericRegex.FindStringSubmatch(bodyContent); len(matches) &gt; 1 </span><span class="cov0" title="0">{
                return convertToR2LangType(matches[1])
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// convertToR2LangType converts string to appropriate R2Lang native type
func convertToR2LangType(value string) interface{} <span class="cov8" title="1">{
        value = strings.TrimSpace(value)

        // Try integer
        if i, err := strconv.Atoi(value); err == nil </span><span class="cov8" title="1">{
                return float64(i) // R2Lang uses float64 for numbers
        }</span>

        // Try float
        <span class="cov8" title="1">if f, err := strconv.ParseFloat(value, 64); err == nil </span><span class="cov8" title="1">{
                return f
        }</span>

        // Try boolean
        <span class="cov8" title="1">switch strings.ToLower(value) </span>{
        case "true":<span class="cov8" title="1">
                return true</span>
        case "false":<span class="cov8" title="1">
                return false</span>
        }

        // Return as string
        <span class="cov8" title="1">return value</span>
}

// tryConvertValue attempts to convert string to appropriate type
func tryConvertValue(value string) interface{} <span class="cov8" title="1">{
        return convertToR2LangType(value)
}</span>

// cleanResponseString removes binary/control characters from response
func cleanResponseString(response string) string <span class="cov8" title="1">{
        // Try to extract clean XML from the response
        xmlStart := strings.Index(response, "&lt;?xml")
        if xmlStart == -1 </span><span class="cov0" title="0">{
                xmlStart = strings.Index(response, "&lt;soap:Envelope")
        }</span>
        <span class="cov8" title="1">if xmlStart == -1 </span><span class="cov0" title="0">{
                xmlStart = strings.Index(response, "&lt;Envelope")
        }</span>

        <span class="cov8" title="1">if xmlStart &gt; 0 </span><span class="cov0" title="0">{
                // Remove everything before the XML declaration
                response = response[xmlStart:]
        }</span>

        // Find the end of the XML
        <span class="cov8" title="1">xmlEnd := strings.LastIndex(response, "&lt;/soap:Envelope&gt;")
        if xmlEnd == -1 </span><span class="cov0" title="0">{
                xmlEnd = strings.LastIndex(response, "&lt;/Envelope&gt;")
        }</span>

        <span class="cov8" title="1">if xmlEnd &gt; 0 </span><span class="cov8" title="1">{
                // Keep only up to the end of the XML
                response = response[:xmlEnd+len("&lt;/soap:Envelope&gt;")]
        }</span>

        // Filter out non-printable characters
        <span class="cov8" title="1">var cleaned strings.Builder
        for _, r := range response </span><span class="cov8" title="1">{
                // Keep XML-safe characters: printable ASCII, newlines, tabs
                if (r &gt;= 32 &amp;&amp; r &lt;= 126) || r == '\n' || r == '\r' || r == '\t' </span><span class="cov8" title="1">{
                        cleaned.WriteRune(r)
                }</span>
        }

        <span class="cov8" title="1">return cleaned.String()</span>
}

// cleanXMLNamespaces removes namespace prefixes to simplify parsing
func cleanXMLNamespaces(xmlData string) string <span class="cov8" title="1">{
        // Remove namespace prefixes like "soap:" or "tns:"
        nsRegex := regexp.MustCompile(`\w+:`)
        cleaned := nsRegex.ReplaceAllString(xmlData, "")

        // Remove namespace declarations
        nsDeclarationRegex := regexp.MustCompile(`\s+xmlns[^=]*="[^"]*"`)
        cleaned = nsDeclarationRegex.ReplaceAllString(cleaned, "")

        return cleaned
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package r2libs

import (
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"
)

// r2std.go: Librería estándar con diversas funciones auxiliares

func RegisterStd(env *r2core.Environment) <span class="cov8" title="1">{
        functions := map[string]r2core.BuiltinFunction{
                "typeOf": r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                return "nil"
                        }</span>
                        <span class="cov8" title="1">val := args[0]
                        return fmt.Sprintf("%T", val)</span>
                }),

                "len": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov8" title="1">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("len needs 1 argument")</span>
                        }
                        <span class="cov8" title="1">switch v := args[0].(type) </span>{
                        case string:<span class="cov8" title="1">
                                return float64(len(v))</span>
                        case []interface{}:<span class="cov8" title="1">
                                return float64(len(v))</span>
                        case map[string]interface{}:<span class="cov0" title="0">
                                return float64(len(v))</span>
                        default:<span class="cov0" title="0">
                                panic("len: Expected string, []interface{}, or map[string]interface{}")</span>
                        }
                }),

                "sleep": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("sleep needs 1 argument (seconds)")</span>
                        }
                        <span class="cov0" title="0">secs, ok := args[0].(float64)
                        if !ok </span><span class="cov0" title="0">{
                                panic("sleep: arg should be a number")</span>
                        }
                        <span class="cov0" title="0">time.Sleep(time.Duration(secs) * time.Second)
                        return nil</span>
                }),

                "parseInt": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov8" title="1">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("parseInt needs 1 argument (string)")</span>
                        }
                        <span class="cov8" title="1">s, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("parseInt: arg should be string")</span>
                        }
                        <span class="cov8" title="1">i, err := strconv.Atoi(s)
                        if err != nil </span><span class="cov0" title="0">{
                                panic("parseInt: could not convert '" + s + "' to int")</span>
                        }
                        <span class="cov8" title="1">return float64(i)</span>
                }),

                "parseFloat": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("parseFloat needs 1 argument (string)")</span>
                        }
                        <span class="cov0" title="0">s, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("parseFloat: arg should be string")</span>
                        }
                        <span class="cov0" title="0">f, err := strconv.ParseFloat(s, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                panic("parseFloat: could not convert '" + s + "' to float")</span>
                        }
                        <span class="cov0" title="0">return f</span>
                }),

                "toString": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("toString needs 1 argument")</span>
                        }
                        <span class="cov0" title="0">return fmt.Sprint(args[0])</span>
                }),

                "range": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("range needs 2 arguments: (start, end)")</span>
                        }
                        <span class="cov0" title="0">start, ok1 := args[0].(float64)
                        end, ok2 := args[1].(float64)
                        if !ok1 || !ok2 </span><span class="cov0" title="0">{
                                panic("range: arg should be number, number")</span>
                        }
                        <span class="cov0" title="0">arr := []interface{}{}
                        for i := int(start); float64(i) &lt; end; i++ </span><span class="cov0" title="0">{
                                arr = append(arr, float64(i))
                        }</span>
                        <span class="cov0" title="0">return arr</span>
                }),

                "now": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) == 0 </span><span class="cov0" title="0">{
                                return time.Now().Format("2006-01-02 15:04:05")
                        }</span>
                        <span class="cov0" title="0">if len(args) == 1 </span><span class="cov0" title="0">{
                                format, ok := args[0].(string)
                                if !ok </span><span class="cov0" title="0">{
                                        panic("now: arg should be string")</span>
                                }
                                <span class="cov0" title="0">return time.Now().Format(format)</span>
                        }
                        <span class="cov0" title="0">panic("now: too many arguments")</span>
                }),

                "join": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("join needs 2 arguments: (array, separator)")</span>
                        }
                        <span class="cov0" title="0">arr, ok := args[0].([]interface{})
                        sep, ok2 := args[1].(string)
                        if !ok || !ok2 </span><span class="cov0" title="0">{
                                panic("join: args should be Array, string")</span>
                        }
                        // Convertir cada elemento a string
                        <span class="cov0" title="0">strArr := make([]string, len(arr))
                        for i, v := range arr </span><span class="cov0" title="0">{
                                strArr[i] = fmt.Sprint(v)
                        }</span>
                        <span class="cov0" title="0">return strings.Join(strArr, sep)</span>
                }),

                "split": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("split needs 2 arguments: (str, separator)")</span>
                        }
                        <span class="cov0" title="0">s, ok1 := args[0].(string)
                        sep, ok2 := args[1].(string)
                        if !ok1 || !ok2 </span><span class="cov0" title="0">{
                                panic("split: args should be string, string")</span>
                        }
                        <span class="cov0" title="0">parts := strings.Split(s, sep)
                        arr := make([]interface{}, len(parts))
                        for i, p := range parts </span><span class="cov0" title="0">{
                                arr[i] = p
                        }</span>
                        <span class="cov0" title="0">return arr</span>
                }),

                "eval": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov8" title="1">{
                        if len(args) &lt; 1 </span><span class="cov8" title="1">{
                                panic("eval needs 1 argument (code string)")</span>
                        }
                        <span class="cov8" title="1">code, ok := args[0].(string)
                        if !ok </span><span class="cov8" title="1">{
                                panic("eval: argument should be a string")</span>
                        }

                        // Crear un nuevo parser para el código dinámico
                        <span class="cov8" title="1">parser := r2core.NewParser(code)
                        program := parser.ParseProgram()

                        // Evaluar en el contexto del entorno actual
                        return program.Eval(env)</span>
                }),

                "keys": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov8" title="1">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("keys needs 1 argument (map)")</span>
                        }
                        <span class="cov8" title="1">mapVal, ok := args[0].(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                panic("keys: argument should be a map")</span>
                        }

                        // Crear array con todas las claves
                        <span class="cov8" title="1">keys := make([]interface{}, 0, len(mapVal))
                        for key := range mapVal </span><span class="cov8" title="1">{
                                keys = append(keys, key)
                        }</span>
                        <span class="cov8" title="1">return keys</span>
                }),

                "print": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov8" title="1">{
                        for i, arg := range args </span><span class="cov8" title="1">{
                                if i &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Print(" ")
                                }</span>
                                <span class="cov8" title="1">fmt.Print(arg)</span>
                        }
                        <span class="cov8" title="1">fmt.Println()
                        return nil</span>
                }),
        }

        <span class="cov8" title="1">RegisterModule(env, "std", functions)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package r2libs

import (
        "fmt"
        "strings"
        "unicode/utf8"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"
)

// r2string.go: Funciones nativas para manipulación de strings en R2

func RegisterString(env *r2core.Environment) <span class="cov8" title="1">{
        functions := map[string]r2core.BuiltinFunction{
                "toUpper": r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov8" title="1">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("toUpper necesita (str)")</span>
                        }
                        <span class="cov8" title="1">s, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("toUpper: argumento debe ser string")</span>
                        }
                        <span class="cov8" title="1">return strings.ToUpper(s)</span>
                }),

                "toLower": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("toLower necesita (str)")</span>
                        }
                        <span class="cov0" title="0">s, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("toLower: argumento debe ser string")</span>
                        }
                        <span class="cov0" title="0">return strings.ToLower(s)</span>
                }),

                "trim": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("trim necesita (str)")</span>
                        }
                        <span class="cov0" title="0">s, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("trim: argumento debe ser string")</span>
                        }
                        <span class="cov0" title="0">return strings.TrimSpace(s)</span>
                }),

                "substring": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 3 </span><span class="cov0" title="0">{
                                panic("substring necesita (str, start, length)")</span>
                        }
                        <span class="cov0" title="0">s, okS := args[0].(string)
                        startF, ok1 := args[1].(float64)
                        lengthF, ok2 := args[2].(float64)
                        if !(okS &amp;&amp; ok1 &amp;&amp; ok2) </span><span class="cov0" title="0">{
                                panic("substring: (str, start, length) =&gt; str y numéricos")</span>
                        }
                        <span class="cov0" title="0">start := int(startF)
                        length := int(lengthF)
                        if start &lt; 0 || length &lt; 0 || start &gt; len(s) </span><span class="cov0" title="0">{
                                return "" // o panic, a tu elección
                        }</span>
                        <span class="cov0" title="0">end := start + length
                        if end &gt; len(s) </span><span class="cov0" title="0">{
                                end = len(s)
                        }</span>
                        <span class="cov0" title="0">return s[start:end]</span>
                }),

                "indexOf": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("indexOf necesita (str, sub)")</span>
                        }
                        <span class="cov0" title="0">s, okS := args[0].(string)
                        sub, okSub := args[1].(string)
                        if !(okS &amp;&amp; okSub) </span><span class="cov0" title="0">{
                                panic("indexOf: argumentos deben ser strings")</span>
                        }
                        <span class="cov0" title="0">idx := strings.Index(s, sub)
                        if idx &lt; 0 </span><span class="cov0" title="0">{
                                return float64(-1)
                        }</span>
                        <span class="cov0" title="0">return float64(idx)</span>
                }),

                "lastIndexOf": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("lastIndexOf necesita (str, sub)")</span>
                        }
                        <span class="cov0" title="0">s, okS := args[0].(string)
                        sub, okSub := args[1].(string)
                        if !(okS &amp;&amp; okSub) </span><span class="cov0" title="0">{
                                panic("lastIndexOf: argumentos deben ser strings")</span>
                        }
                        <span class="cov0" title="0">idx := strings.LastIndex(s, sub)
                        if idx &lt; 0 </span><span class="cov0" title="0">{
                                return float64(-1)
                        }</span>
                        <span class="cov0" title="0">return float64(idx)</span>
                }),

                "startsWith": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("startsWith necesita (str, prefix)")</span>
                        }
                        <span class="cov0" title="0">s, okS := args[0].(string)
                        prefix, okP := args[1].(string)
                        if !(okS &amp;&amp; okP) </span><span class="cov0" title="0">{
                                panic("startsWith: argumentos deben ser strings")</span>
                        }
                        <span class="cov0" title="0">return strings.HasPrefix(s, prefix)</span>
                }),

                "endsWith": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("endsWith necesita (str, suffix)")</span>
                        }
                        <span class="cov0" title="0">s, okS := args[0].(string)
                        suffix, okP := args[1].(string)
                        if !(okS &amp;&amp; okP) </span><span class="cov0" title="0">{
                                panic("endsWith: argumentos deben ser strings")</span>
                        }
                        <span class="cov0" title="0">return strings.HasSuffix(s, suffix)</span>
                }),

                "replace": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 3 </span><span class="cov0" title="0">{
                                panic("replace necesita (str, old, new)")</span>
                        }
                        <span class="cov0" title="0">s, sOk := args[0].(string)
                        oldS, oOk := args[1].(string)
                        newS, nOk := args[2].(string)
                        if !(sOk &amp;&amp; oOk &amp;&amp; nOk) </span><span class="cov0" title="0">{
                                panic("replace: (str, old, new) =&gt; strings")</span>
                        }
                        <span class="cov0" title="0">return strings.ReplaceAll(s, oldS, newS)</span>
                }),

                "split": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("split necesita (str, sep)")</span>
                        }
                        <span class="cov0" title="0">s, ok1 := args[0].(string)
                        sep, ok2 := args[1].(string)
                        if !(ok1 &amp;&amp; ok2) </span><span class="cov0" title="0">{
                                panic("split: argumentos deben ser strings")</span>
                        }
                        <span class="cov0" title="0">parts := strings.Split(s, sep)
                        arr := make([]interface{}, len(parts))
                        for i, p := range parts </span><span class="cov0" title="0">{
                                arr[i] = p
                        }</span>
                        <span class="cov0" title="0">return arr</span>
                }),

                "join": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("join necesita (array, sep)")</span>
                        }
                        <span class="cov0" title="0">arr, ok1 := args[0].([]interface{})
                        sep, ok2 := args[1].(string)
                        if !(ok1 &amp;&amp; ok2) </span><span class="cov0" title="0">{
                                panic("join: primer argumento array nativo, segundo un string")</span>
                        }
                        <span class="cov0" title="0">strArr := make([]string, len(arr))
                        for i, v := range arr </span><span class="cov0" title="0">{
                                strArr[i] = fmt.Sprint(v) // conviertes a string
                        }</span>
                        <span class="cov0" title="0">return strings.Join(strArr, sep)</span>
                }),

                "lengthOfString": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("lengthOfString necesita (str)")</span>
                        }
                        <span class="cov0" title="0">s, ok := args[0].(string)
                        if !ok </span><span class="cov0" title="0">{
                                panic("lengthOfString: argumento debe ser string")</span>
                        }
                        // length en caracteres (runas), no bytes
                        <span class="cov0" title="0">return float64(utf8.RuneCountInString(s))</span>
                }),
        }

        <span class="cov8" title="1">RegisterModule(env, "string", functions)</span>
}</pre>
		
		<pre class="file" id="file21" style="display: none">package r2libs

import (
        "fmt"
        "reflect"
        "strings"
        "time"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"
)

// Estructura interna para guardar el resultado de cada test
type testResult struct {
        name    string
        passed  bool
        message string
        elapsed time.Duration
}

func RegisterTest(env *r2core.Environment) <span class="cov8" title="1">{
        functions := map[string]r2core.BuiltinFunction{
                "assertEq": r2core.BuiltinFunction(func(args ...interface{}) interface{} </span><span class="cov0" title="0">{
                        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                                panic("assertEq necesita (actual, expected, [msg])")</span>
                        }
                        <span class="cov0" title="0">actual := args[0]
                        expected := args[1]
                        var msg string
                        if len(args) &gt;= 3 </span><span class="cov0" title="0">{
                                if m, ok := args[2].(string); ok </span><span class="cov0" title="0">{
                                        msg = m
                                }</span>
                        }
                        <span class="cov0" title="0">if !reflect.DeepEqual(actual, expected) </span><span class="cov0" title="0">{
                                if msg == "" </span><span class="cov0" title="0">{
                                        msg = fmt.Sprintf("assertEq fallo: actual=%v, expected=%v", actual, expected)
                                }</span> else<span class="cov0" title="0"> {
                                        msg = fmt.Sprintf("%s (actual=%v, expected=%v)", msg, actual, expected)
                                }</span>
                                <span class="cov0" title="0">panic(msg)</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }),

                "assertTrue": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                                panic("assertTrue necesita (cond, [msg])")</span>
                        }
                        <span class="cov0" title="0">cond := toBool(args[0])
                        var msg string
                        if len(args) &gt;= 2 </span><span class="cov0" title="0">{
                                if m, ok := args[1].(string); ok </span><span class="cov0" title="0">{
                                        msg = m
                                }</span>
                        }
                        <span class="cov0" title="0">if !cond </span><span class="cov0" title="0">{
                                if msg == "" </span><span class="cov0" title="0">{
                                        msg = "assertTrue fallo: la condición es falsa"
                                }</span>
                                <span class="cov0" title="0">panic(msg)</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }),

                "runAllTests": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        // Recolectar nombres de funciones que empiecen con "test" (insensitive o no)
                        var testNames []string
                        for k, v := range env.GetStore() </span><span class="cov0" title="0">{
                                // Podrías chequear en e.outer también si deseas
                                if strings.HasPrefix(strings.ToLower(k), "test") </span><span class="cov0" title="0">{
                                        // Chequeamos si es *UserFunction
                                        if _, isFunc := v.(*r2core.UserFunction); isFunc </span><span class="cov0" title="0">{
                                                testNames = append(testNames, k)
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">if len(testNames) == 0 </span><span class="cov0" title="0">{
                                fmt.Println("No se encontraron funciones test* en este script.")
                                return nil
                        }</span>
                        // Ordenar alfabéticamente, si quieres
                        // sort.Strings(testNames)

                        <span class="cov0" title="0">var results []testResult
                        startGlobal := time.Now()

                        for _, tName := range testNames </span><span class="cov0" title="0">{
                                start := time.Now()
                                testPassed := true
                                testMsg := ""

                                // Capturar panic
                                func() </span><span class="cov0" title="0">{
                                        defer func() </span><span class="cov0" title="0">{
                                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                                        testPassed = false
                                                        testMsg = fmt.Sprint(r)
                                                }</span>
                                        }()
                                        // Llamar la función
                                        <span class="cov0" title="0">val, _ := env.Get(tName) // ya sabemos que es *UserFunction
                                        fn, _ := val.(*r2core.UserFunction)
                                        fn.Call()</span> // sin args
                                }()
                                <span class="cov0" title="0">elapsed := time.Since(start)
                                results = append(results, testResult{
                                        name:    tName,
                                        passed:  testPassed,
                                        message: testMsg,
                                        elapsed: elapsed,
                                })</span>
                        }
                        <span class="cov0" title="0">endGlobal := time.Since(startGlobal)

                        // Mostrar reporte
                        passedCount := 0
                        for _, r := range results </span><span class="cov0" title="0">{
                                status := "PASSED"
                                if !r.passed </span><span class="cov0" title="0">{
                                        status = "FAILED"
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("[%s] %s (%.2f ms)\n", status, r.name, float64(r.elapsed.Microseconds())/1000.0)
                                if !r.passed </span><span class="cov0" title="0">{
                                        // indent el message
                                        lines := strings.Split(r.message, "\n")
                                        for _, ln := range lines </span><span class="cov0" title="0">{
                                                fmt.Printf("   %s\n", ln)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        passedCount++
                                }</span>
                        }
                        <span class="cov0" title="0">total := len(results)
                        failedCount := total - passedCount
                        fmt.Printf("\nResumen: %d PASSED, %d FAILED, %d TOTAL (%.2f ms)\n",
                                passedCount, failedCount, total, float64(endGlobal.Microseconds())/1000.0)

                        return nil</span>
                }),

                "printStep": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        for _, arg := range args </span><span class="cov0" title="0">{
                                fmt.Print(arg, " ")
                        }</span>
                        <span class="cov0" title="0">fmt.Println()
                        return nil</span>
                }),

                "assertEqual": r2core.BuiltinFunction(func(args ...interface{}) interface{} <span class="cov0" title="0">{
                        if len(args) != 2 </span><span class="cov0" title="0">{
                                panic("assertEqual requiere exactamente 2 argumentos")</span>
                        }
                        <span class="cov0" title="0">a, b := args[0], args[1]
                        if !equals(a, b) </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("Assertion Failed: %v != %v", a, b))</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                }),
        }
        
        <span class="cov8" title="1">RegisterModule(env, "test", functions)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package r2libs

import (
        "regexp"
        "strings"
        "unicode"
        "unicode/utf8"

        "github.com/arturoeanton/go-r2lang/pkg/r2core"
        "golang.org/x/text/collate"
        "golang.org/x/text/language"
        "golang.org/x/text/unicode/norm"
)

func RegisterUnicode(env *r2core.Environment) <span class="cov8" title="1">{
        functions := map[string]r2core.BuiltinFunction{
                "ulen":           r2core.BuiltinFunction(unicodeLength),
                "usubstr":        r2core.BuiltinFunction(unicodeSubstring),
                "uupper":         r2core.BuiltinFunction(unicodeUpper),
                "ulower":         r2core.BuiltinFunction(unicodeLower),
                "utitle":         r2core.BuiltinFunction(unicodeTitle),
                "ureverse":       r2core.BuiltinFunction(unicodeReverse),
                "unormalize":     r2core.BuiltinFunction(unicodeNormalize),
                "ucompare":       r2core.BuiltinFunction(unicodeCompare),
                "uisvalid":       r2core.BuiltinFunction(isValidUTF8),
                "ucharcode":      r2core.BuiltinFunction(getCharCode),
                "ufromcode":      r2core.BuiltinFunction(fromCharCode),
                "uisLetter":      r2core.BuiltinFunction(isLetter),
                "uisDigit":       r2core.BuiltinFunction(isDigit),
                "uisSpace":       r2core.BuiltinFunction(isSpace),
                "uisPunct":       r2core.BuiltinFunction(isPunct),
                "uisUpper":       r2core.BuiltinFunction(isUpper),
                "uisLower":       r2core.BuiltinFunction(isLower),
                "ugetCategory":   r2core.BuiltinFunction(getCategory),
                "uregex":         r2core.BuiltinFunction(unicodeRegex),
                "uregexMatch":    r2core.BuiltinFunction(unicodeRegexMatch),
                "uregexReplace":  r2core.BuiltinFunction(unicodeRegexReplace),
        }
        
        RegisterModule(env, "unicode", functions)
}</span>

// ============================================================
// FUNCIONES BÁSICAS DE STRING UNICODE
// ============================================================

// unicodeLength retorna la longitud en caracteres Unicode (no bytes)
func unicodeLength(args ...interface{}) interface{} <span class="cov8" title="1">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                panic("ulen() requiere exactamente 1 argumento")</span>
        }

        <span class="cov8" title="1">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("ulen() requiere un string")</span>
        }

        <span class="cov8" title="1">return float64(utf8.RuneCountInString(str))</span>
}

// unicodeSubstring extrae substring basado en caracteres Unicode
func unicodeSubstring(args ...interface{}) interface{} <span class="cov8" title="1">{
        if len(args) &lt; 2 || len(args) &gt; 3 </span><span class="cov0" title="0">{
                panic("usubstr() requiere 2 o 3 argumentos")</span>
        }

        <span class="cov8" title="1">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("usubstr() requiere un string como primer argumento")</span>
        }

        <span class="cov8" title="1">start, ok := args[1].(float64)
        if !ok </span><span class="cov0" title="0">{
                panic("usubstr() requiere un número como segundo argumento")</span>
        }

        <span class="cov8" title="1">runes := []rune(str)
        startIdx := int(start)

        if startIdx &lt; 0 </span><span class="cov0" title="0">{
                startIdx = 0
        }</span>
        <span class="cov8" title="1">if startIdx &gt;= len(runes) </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">endIdx := len(runes)
        if len(args) == 3 </span><span class="cov8" title="1">{
                length, ok := args[2].(float64)
                if !ok </span><span class="cov0" title="0">{
                        panic("usubstr() requiere un número como tercer argumento")</span>
                }
                <span class="cov8" title="1">endIdx = startIdx + int(length)
                if endIdx &gt; len(runes) </span><span class="cov0" title="0">{
                        endIdx = len(runes)
                }</span>
                <span class="cov8" title="1">if endIdx &lt; startIdx </span><span class="cov0" title="0">{
                        endIdx = startIdx
                }</span>
        }

        <span class="cov8" title="1">return string(runes[startIdx:endIdx])</span>
}

// unicodeUpper convierte a mayúsculas usando reglas Unicode
func unicodeUpper(args ...interface{}) interface{} <span class="cov8" title="1">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                panic("uupper() requiere exactamente 1 argumento")</span>
        }

        <span class="cov8" title="1">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("uupper() requiere un string")</span>
        }

        <span class="cov8" title="1">return strings.ToUpper(str)</span>
}

// unicodeLower convierte a minúsculas usando reglas Unicode
func unicodeLower(args ...interface{}) interface{} <span class="cov8" title="1">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                panic("ulower() requiere exactamente 1 argumento")</span>
        }

        <span class="cov8" title="1">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("ulower() requiere un string")</span>
        }

        <span class="cov8" title="1">return strings.ToLower(str)</span>
}

// unicodeTitle convierte a formato título
func unicodeTitle(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                panic("utitle() requiere exactamente 1 argumento")</span>
        }

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("utitle() requiere un string")</span>
        }

        <span class="cov0" title="0">return strings.ToTitle(str)</span>
}

// unicodeReverse invierte un string respetando caracteres Unicode
func unicodeReverse(args ...interface{}) interface{} <span class="cov8" title="1">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                panic("ureverse() requiere exactamente 1 argumento")</span>
        }

        <span class="cov8" title="1">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("ureverse() requiere un string")</span>
        }

        <span class="cov8" title="1">runes := []rune(str)
        for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                runes[i], runes[j] = runes[j], runes[i]
        }</span>

        <span class="cov8" title="1">return string(runes)</span>
}

// ============================================================
// NORMALIZACIÓN UNICODE
// ============================================================

// unicodeNormalize normaliza un string usando formas Unicode estándar
func unicodeNormalize(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 1 || len(args) &gt; 2 </span><span class="cov0" title="0">{
                panic("unormalize() requiere 1 o 2 argumentos")</span>
        }

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("unormalize() requiere un string")</span>
        }

        <span class="cov0" title="0">form := "NFC" // Por defecto
        if len(args) == 2 </span><span class="cov0" title="0">{
                if formArg, ok := args[1].(string); ok </span><span class="cov0" title="0">{
                        form = formArg
                }</span>
        }

        <span class="cov0" title="0">var normalizer norm.Form
        switch form </span>{
        case "NFC":<span class="cov0" title="0">
                normalizer = norm.NFC</span>
        case "NFD":<span class="cov0" title="0">
                normalizer = norm.NFD</span>
        case "NFKC":<span class="cov0" title="0">
                normalizer = norm.NFKC</span>
        case "NFKD":<span class="cov0" title="0">
                normalizer = norm.NFKD</span>
        default:<span class="cov0" title="0">
                panic("Forma de normalización inválida: " + form + " (usar NFC, NFD, NFKC, NFKD)")</span>
        }

        <span class="cov0" title="0">return normalizer.String(str)</span>
}

// unicodeCompare compara strings usando collation Unicode
func unicodeCompare(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 2 || len(args) &gt; 3 </span><span class="cov0" title="0">{
                panic("ucompare() requiere 2 o 3 argumentos")</span>
        }

        <span class="cov0" title="0">str1, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("ucompare() requiere strings")</span>
        }

        <span class="cov0" title="0">str2, ok := args[1].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("ucompare() requiere strings")</span>
        }

        <span class="cov0" title="0">locale := "en"
        if len(args) == 3 </span><span class="cov0" title="0">{
                if localeArg, ok := args[2].(string); ok </span><span class="cov0" title="0">{
                        locale = localeArg
                }</span>
        }

        <span class="cov0" title="0">tag := language.Make(locale)
        col := collate.New(tag)

        result := col.CompareString(str1, str2)
        return float64(result)</span>
}

// ============================================================
// VALIDACIÓN Y UTILIDADES
// ============================================================

// isValidUTF8 verifica si un string es UTF-8 válido
func isValidUTF8(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                panic("uisvalid() requiere exactamente 1 argumento")</span>
        }

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("uisvalid() requiere un string")</span>
        }

        <span class="cov0" title="0">return utf8.ValidString(str)</span>
}

// getCharCode obtiene el código Unicode del primer carácter
func getCharCode(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                panic("ucharcode() requiere exactamente 1 argumento")</span>
        }

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("ucharcode() requiere un string")</span>
        }

        <span class="cov0" title="0">if str == "" </span><span class="cov0" title="0">{
                panic("ucharcode() requiere un string no vacío")</span>
        }

        <span class="cov0" title="0">r, _ := utf8.DecodeRuneInString(str)
        return float64(r)</span>
}

// fromCharCode crea un string desde un código Unicode
func fromCharCode(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                panic("ufromcode() requiere exactamente 1 argumento")</span>
        }

        <span class="cov0" title="0">code, ok := args[0].(float64)
        if !ok </span><span class="cov0" title="0">{
                panic("ufromcode() requiere un número")</span>
        }

        <span class="cov0" title="0">r := rune(code)
        if !utf8.ValidRune(r) </span><span class="cov0" title="0">{
                panic("Código Unicode inválido")</span>
        }

        <span class="cov0" title="0">return string(r)</span>
}

// ============================================================
// CLASIFICACIÓN DE CARACTERES
// ============================================================

func getFirstRune(args []interface{}, funcName string) rune <span class="cov0" title="0">{
        if len(args) != 1 </span><span class="cov0" title="0">{
                panic(funcName + "() requiere exactamente 1 argumento")</span>
        }

        <span class="cov0" title="0">str, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic(funcName + "() requiere un string")</span>
        }

        <span class="cov0" title="0">if str == "" </span><span class="cov0" title="0">{
                panic(funcName + "() requiere un string no vacío")</span>
        }

        <span class="cov0" title="0">r, _ := utf8.DecodeRuneInString(str)
        return r</span>
}

func isLetter(args ...interface{}) interface{} <span class="cov0" title="0">{
        char := getFirstRune(args, "uisLetter")
        return unicode.IsLetter(char)
}</span>

func isDigit(args ...interface{}) interface{} <span class="cov0" title="0">{
        char := getFirstRune(args, "uisDigit")
        return unicode.IsDigit(char)
}</span>

func isSpace(args ...interface{}) interface{} <span class="cov0" title="0">{
        char := getFirstRune(args, "uisSpace")
        return unicode.IsSpace(char)
}</span>

func isPunct(args ...interface{}) interface{} <span class="cov0" title="0">{
        char := getFirstRune(args, "uisPunct")
        return unicode.IsPunct(char)
}</span>

func isUpper(args ...interface{}) interface{} <span class="cov0" title="0">{
        char := getFirstRune(args, "uisUpper")
        return unicode.IsUpper(char)
}</span>

func isLower(args ...interface{}) interface{} <span class="cov0" title="0">{
        char := getFirstRune(args, "uisLower")
        return unicode.IsLower(char)
}</span>

func getCategory(args ...interface{}) interface{} <span class="cov0" title="0">{
        char := getFirstRune(args, "ugetCategory")
        for name, table := range unicode.Categories </span><span class="cov0" title="0">{
                if unicode.In(char, table) </span><span class="cov0" title="0">{
                        return name
                }</span>
        }
        <span class="cov0" title="0">return "Unknown"</span>
}

// ============================================================
// EXPRESIONES REGULARES UNICODE
// ============================================================

// unicodeRegex busca patrones usando regex con soporte Unicode
func unicodeRegex(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                panic("uregex() requiere al menos 2 argumentos")</span>
        }

        <span class="cov0" title="0">pattern, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("Patrón debe ser string")</span>
        }

        <span class="cov0" title="0">text, ok := args[1].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("Texto debe ser string")</span>
        }

        // Compilar regex con soporte Unicode
        <span class="cov0" title="0">re, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                panic("Patrón regex inválido: " + err.Error())</span>
        }

        <span class="cov0" title="0">matches := re.FindAllString(text, -1)
        result := make([]interface{}, len(matches))
        for i, match := range matches </span><span class="cov0" title="0">{
                result[i] = match
        }</span>

        <span class="cov0" title="0">return result</span>
}

// unicodeRegexMatch verifica si un patrón coincide
func unicodeRegexMatch(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) != 2 </span><span class="cov0" title="0">{
                panic("uregexMatch() requiere exactamente 2 argumentos")</span>
        }

        <span class="cov0" title="0">pattern, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("Patrón debe ser string")</span>
        }

        <span class="cov0" title="0">text, ok := args[1].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("Texto debe ser string")</span>
        }

        <span class="cov0" title="0">re, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                panic("Patrón regex inválido: " + err.Error())</span>
        }

        <span class="cov0" title="0">return re.MatchString(text)</span>
}

// unicodeRegexReplace reemplaza patrones en texto
func unicodeRegexReplace(args ...interface{}) interface{} <span class="cov0" title="0">{
        if len(args) != 3 </span><span class="cov0" title="0">{
                panic("uregexReplace() requiere exactamente 3 argumentos")</span>
        }

        <span class="cov0" title="0">pattern, ok := args[0].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("Patrón debe ser string")</span>
        }

        <span class="cov0" title="0">replacement, ok := args[1].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("Reemplazo debe ser string")</span>
        }

        <span class="cov0" title="0">text, ok := args[2].(string)
        if !ok </span><span class="cov0" title="0">{
                panic("Texto debe ser string")</span>
        }

        <span class="cov0" title="0">re, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                panic("Patrón regex inválido: " + err.Error())</span>
        }

        <span class="cov0" title="0">return re.ReplaceAllString(text, replacement)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
